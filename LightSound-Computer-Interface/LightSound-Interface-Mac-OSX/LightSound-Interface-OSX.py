###################################################
######     LightSound Computer Interface     ######
######             Version 1.0.0             ######
######        created by SÃ³ley Hyman         ######
######      https://soleyhyman.github.io     ######
###################################################

# Import packages
import sys
from datetime import datetime
import os
from pathlib import Path
import time
import threading
import configparser
from html.parser import HTMLParser
import webbrowser

import numpy as np
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.figure import Figure

import serial
import serial.tools.list_ports

import wx
import wx.adv
from wx.lib.embeddedimage import PyEmbeddedImage
import wx.html as html
import wx.html2 as html2


def LightSoundLogoIcon():
    return PyEmbeddedImage(
    b'iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAABHNCSVQICAgIfAhkiAAAIABJ'
    b'REFUeJzsvWmMXNd5Jvycu9/au3ohm5tEiqJEWrJEy7I2a1e8SbJkyVJGdmIMPLG/JMhg4DFm'
    b'gmAQDObP/LJjB4GDGEHgRPjs2IZhWY4/ObajjSK1mqJIiWyRIiluzd7YXdutqruf78c55y7V'
    b'CymKZFd31wNcVrO6+tbd3ufd30MwNwjf6Dy/E69Bf/8DOx0nvC0I5vpoDz30cK7QdRlA4yvV'
    b'6ovPAJAABB1bmNiEwM0no3Se36WgnOexCoKQ2m2f2HaIMOwRQA89fBgwGXI0ACaYfPkAPMRK'
    b'F2BCTRI/fyh8UAIgHT9LH/YAeuihh6Sx7RoAsvwNF0zGOgkgqd3ns9TPCXMRAJnjvc7fk7k/'
    b'd7Y/7aGHHhYCpb4JIAdm8suIlawQ+hBpAlhI+M9KDvNZAGf7Q6H9KUB6Ut9DDxcMYQaMAHzE'
    b'wh8ijgGI14VklJ7l9xHONwYARFZAz/fvoYcLBUoDA4wAXP5WCEYGYhMuwQVRvB+EAJLRf/Gz'
    b'BNCeBdBDDxcEBEBoAMiAmf8BWBDQ5a/CJUjKosB5aeIPGwTsCX8PPVxAEBLqYFkAgAm9A0BF'
    b'WviT24cywc/HBeg8gB4J9NDDBQKlVAGggWl/FbHwdxLABcGHTeP1hL+HHi4gOAGoYMp5LsGf'
    b'y/w/b3wYAugJfw89XHCEMtLCLzJuF8Xq7lkAPfTQXRACL2G28F9w9Cr5euihq0CiMntcBJO/'
    b'Ex+mDmAZo7PS8lyufbIwq/OezfW7+fZPMfc+LvTxnu/+zvW7OoPTC32Odnzmg1zDZReHXkjo'
    b'L/iJ9iyAWWAPmiwrMAw99d7CYBkZXdegaeqs/UkSgWHoIIR9TlVV6LrWsX8KQiSYpg5JOtd+'
    b'DyZAiiKO98Nmhtj+ZFnmxyEhLXyArutQFCX13ux9AJqm8muxUMHa7Gtmmgb/3vgzABLnSEEI'
    b'ga7rUFVlgf0vG1w0hpPn+bK5vrAzCCEDkFR18x/7PtZRelGP8xKBPWyFQhZPPHE3/tN/ugvT'
    b'03WMjZ3BuWi7VavK+OY3H8Ptt1+LAweOo9m0AQCGoeKzn/0E/uzPHoDjeGi3HXz96/fjD/7g'
    b'Yzh5cgozM7Vo3w8+eBP+/M8/D8/zcfLkJFib9ULXlaJYzOJLX7oXTzxxN6an6zh9euosx7vw'
    b'NTAMDffffzP+9E8fhOv6OHp0jP8uxLZtl+O//bcvYMuWdTh69DTabbvju9i1WLduAN/85mO4'
    b'6aarsX//scTnktcsxPr1q/Cnf/oAbrvtWrz//hg+8pHL8Y1vPIpSKYcjR07D83wABKVSDn/x'
    b'F5/H5z73CRw+PIa1a/vxl3/5h9i4cRj79x+D53U2zS09KIoESqf3hWFlHKz4xwFg81cHcUGQ'
    b'KAdeqOX3nC5GzwKYBYpCIYN77rkeX/zi7di6dQPOrmGY1h0aKuGhh27BQw/dgoGBIu+SoDBN'
    b'DbfcshWPP34ntm/fjMHBEj796Rvw4IO3YP36IYh7KcsSbr55K/7wD+/Exz++Bbp+Lh4aO947'
    b'7/woHnnkNmzZsu7DnT4A09TwiU9chccfvx3bt18RWS1AiM2b1+ALX7gNn/70DSiVcnP+vSQB'
    b'q1eX8cUv3o4HHrgJ/f1FzH0NQ6xZU8YDD9yEhx66BatW9eGaay7HF75wG26//RqYphZ9sljM'
    b'4vOfvwVf+MJt2LBhCJdfvhqPP34H7r33euRy5jz7X/K46IzWswBmgcDzfExN1bFv31Hs2PE2'
    b'qtUm5r4syQYtAtt2MT5ewc6db2P37vfgOEwrBUGImRkLIyMn8fzzb+H48QmMjVXw2mvv4o03'
    b'DqLZdAAQUEpRqzXx7run8Nxzb+H06RlQGmC2T5z8XsDzAkxO1vDmm+9h1653UK1a8xzvfBDC'
    b'w/bn+xSVioX9+4/j+ef3YXJyJtqfZdkYG5vGiy/uw4EDJ+C6XsfxAZQC7baLiYkKdu58B7t3'
    b'vxdp8s5r3W67mJys4eWXD+DNN9/D+HgF778/hmeffQvHjk1ADJrxPB+TkzX8/veHsHPnfkxN'
    b'VXH06DheeGEvRkZOIgzDOfa/tLAYFkCPAFJgx08phSRJsG0Px49PwnFEW3YS7Lpffvkwrrpq'
    b'AxqNNur1Fg4fPol33z2BVsuNP0kBQgjCkOLEiQk0Gm2oqgLLamN09ExCOJhvSylw/Pgkmk0b'
    b'V121HpdfvgYzMw34fhDts6+vgOuv3wxAQrVqQVFkuK6HkyfPwLZdfNDgZTZr4PrrNyObzeDM'
    b'mTomJirYv/8YJiZmQKNHjMCy2nj33eM4cuQ02m0Hq1b147rrroBtM9dGwLZdHDx4AgcPnkS7'
    b'PdfxsJ/bbQ+HD5/CwYMnYFnMZVJVGadOnUG12gSlggACHD06iv37j6HRaIFSQFFkTE5WMTFR'
    b'+QDn273oEcCig2nV1avL+B//4zH8yZ98FqdPn8HIyDHMFQ3PZk389V9/Gf/9vz+C48cnceTI'
    b'KFzXRzwejQl1sWjiT/7kc/irv/pDNBptNBot/O///cd48MGb8e67J3Hy5DgAAkmS8ed//nn8'
    b'r//1BNptGxMTFfzf//tVfOUrf4C9e49gdHQKlAKGoeDRR+/At7/9dWQyOg4fHsM3vvEIvva1'
    b'+zE6egYjI8fnON75oSgEd955Hb73vb/A5s1r8dJLb6PVasH3aUr4xfn4foggCCFJEv7rf30I'
    b'f/3XX4bjeHj77SPwvCD63iBgn4v/vhNsf/HnKB5//C78n//zFfT15fH73x+EbTuJ/VH4fgBF'
    b'kXHHHR/F3/7tn2PTptXYtesAWq3OGMPSw2IQwApOA87vM/p+EGn0VsuZ51PMtK/XW6jVmmi3'
    b'Ha6tZgteEFBYls33Z8N1fdTrLaiqDNv24iOiFJbVQq3WgmXZcN0AtVoTtZqV+lwYUjSbNqpV'
    b'C41GC57no9FooV5vLnC8858zM9kdVCoW6vUmgkAI8ULPELNU6vU2arUmLKvNzfBz/e65Mlzs'
    b'vBqNFhqNVsf+ki4GhW27qNUs1OvtlGXUwwfDQpp+rjsmChQk8CaFTObTv7FtehObZ7aUGJiZ'
    b'25omIwxDeF78sEkSwcBACaVSFqdOTSW0S2cUG+jvL6BYzOL06RmurTDn54rFLPr7C5iaqqLV'
    b'cjA01AdFkTE+PsNdAIZCIYuBgSKmpqpoNtsYGuqDYWgJV4EhlzOxdu0ApqfrmJ6uo7+/gFzO'
    b'xMREJWGKzz4ORZGgKBJcN0jNcTQMDevXD6HZbGNsbCZBZum/77xmhUIWg4NFTExUYVmt6NOE'
    b'AJomg1LAdQNIEvs73w/h+2Hqc6rKDFHXDWCaOoaHy6hULFSrVuQCdGYZDEPF6tX9aLcd7gJ0'
    b'nu9SA4WuKwiCg/+v7x/dA8ACUAdQAVDjP1sAWmDWwNksATLP+ymsUBeAXZPh4X785//8aaxb'
    b'N4jDh09HZiiL2n8EN998NSYmKok03Vw+rINq1UpooblrNxzHQ7VqwXF8runbqNebCS2X/FwD'
    b'juOBUsCy2qjVrIQpzQjqyivX4oEHbkYYhjh2bBytloNazeIm+FzHAUiShD/4gxvw4IO3YnKy'
    b'ikrFYp8kwJo1/Xj44VuQz2dw+PDpeYJqITZsWIUnnrgba9YM4NSpKTQaTVSrFg8GxujvL+DL'
    b'X74P27ZdhiNHxnDllWvx5S/fC03TcOzYRLS//v4ivvjFO3DttZswOnoGtRoTfBY3EOcx+7r7'
    b'fohqtRGlWpfOszc/ei7AJYQkAR/96EZ885uP4uDBU3jppXd4vp+iv7+AL33pbtxyyzZUKhbe'
    b'e+/EPHthJEsX5NgY838uHeHv/FzaD6cwDAV33nkd/vIvH8dPf7oDr7xygLsgomhn7nufzer4'
    b'oz+6B/fd9zFMTlZx/PgYXJdCUSRs374Z//N/Po433jiInTvfweRkZY79hPjYx67En/3Zgzh6'
    b'dAz79h1Fo2GB0rQekSSCTZuG8Y1vPIqZmTrefPMIbr11G/7qr57Aj370PF59dQStVgtAiC1b'
    b'1uK//JfPQtcVjIycwNRUBfScZ8wsfaFfbKxQC4DB9wPIsoRXXhnBa6+9G2lxSllF3sREBc89'
    b't+csUebOyzIXOj+z0N+c/XNhyOIAruvjhRf24sCB44iv//z3IAxZhd/UVA2//e3vMT5eBaXs'
    b'fIOAglKKV14ZwRtvHOQWR+e+2OckScLrrx/E7t2HOjIOIosivkvC3r1HsWPHPjiOC9v28OKL'
    b'e7F//7FIyIOAQlFkvPPOMbz88gE0Gq3zvJ5LH4thAazoGAAAyLKEMKQJnzf2dSWJnCWKvViY'
    b'79jP5e8IZFnigT4gec6yzHz7+fcnyoSVxOcwx2dF+TNLnQo3R5JkUBp2XGvK3wco7cZrfamw'
    b'ODGAFesCJFNQc70vtGL8Xvfhg5OTOOfOqHnn+wtpXnT8/fzpvXR8gyIMO/fPXueL9vdw8bGC'
    b'CQA424Pevfgwx/dhzzkdjV9YwcwO3p3/9/ZwMbDCCaCHc8eHsYaSJNET+G5CjwB6WAALtfEK'
    b'zCfQ87mfZysI6uFSokcASw4Xu+ttrvhv8n0ewCM8KjznwlA0ivKzOCHt2Ef6s/HverjU6BFA'
    b'12Kx2lvn1tCExMJOCOEbQAQTdO6FZwhoSEHBOh1BAUoJ/4Z01qXnJiwOegTQNfggAh8LSFoB'
    b'kzne6/iW6GvoHO8l308KPiARAiKR1KskEbBM3+wvpJQipBQ0pAhD9n/2nvgZ0TbbMuiRwaVC'
    b'jwAWHecWRY80Lte+7L3Z/wfIORMATQkjTeT1xXfGwi9JBLIsXiW2SRIkOT42JDR9SCnCkCIM'
    b'KIIwRBiytGoYsi2gFDQMOTmAuwzzxQx6JHCx0COAS46zC3xSsCUp+SpxrZv+XcokJ3NbB0nZ'
    b'jsxzGgukIIAkCTDhRyT8sixBUQgUWYKiyFBkCZIsrAJ2/IJMwjBEELA6C98P4QchAp/CD/jP'
    b'QYggIAgFKVAKGgJhFDOYyz3oEcGFRo8ALgkWFvpOgZckKdK0kiSlXpMbe499fm4SmK1VRVBO'
    b'CD0jgBBhEKaIgHVLcuGXCBN8RYKqSlAVCYrKCEBYBWKGKaVAEFKEQQif9+97XgjPC+DN8bPo'
    b'DhRWAgm5RRLOddV61sCFRo8ALirmi6bHWj4pxEywZShK/KqqCtO2igJVlaAoCm/plaEocooM'
    b'0gQwtysQ+eJC8MMwGsgRBOz/oCLaTyFLgCzHwq8pElSNk4AiXAF2PnFfAdP+Qshd14fjBuzV'
    b'CeC6AZzovQCu58P3hJUQMgIhnRZB5zXtEcGFQI8ALjjm781gwiml/Wg5FmZVVaCqCjQtuakd'
    b'rwr/nAxVFSTAiKDTHQBiN0BY9p0EwEz0AEEQMAIIAoQ0BKEUhFBIEqDIgCITqCqJSEBRJSiy'
    b'iAvE38F8/TDW9q4Px/Fhi81mW9v20LZ92LYHx5EjMvC8IJo4FIQUJAgRUtKRThQ/90jgw6JH'
    b'ABcMcwt+p2kfC7wCTZO5wKvQdbYZhgbDEK9sE+/r+mwSUBQlYQXEBBB/Pz+6VPBPBOS4oEUE'
    b'ECAMA9AwBBCCIIQkCSsAUBVAVZg7oArzX+bfQWmk/f0ghOeH8NwgFn7bQ7vNBL/V9tBquWi1'
    b'+M9tD23bg237cGyfWwUBswgIidwDOosIeiTwYdEjgA+Fs2l7ktDyTGCFNk8KvGlqME0dmQzb'
    b'xM/sdzpMky0iEhOAGml/4QaIuEHSAphv/oAI0gltHQQBwsBHEAagQcC78kIQBJAIhURCyDKF'
    b'IgMytwiEa0BIHFCklPn9gR/EBOAmND4X9mbLRbPJNou/NhOEIKwEx/XhyQF8j8DnMQpBBLNJ'
    b'oEcG54MeAVxQkChwJklSZNZrmhIJvBB209SRzRrIZAxks+zn5P/FZ4Q1wIRfjUiExQg6hR+z'
    b'XIAkOt0AGvLgWxAiDIX25x2m1AdBwEkgZCQgUUgSZaQgARKhoneS748iCCkCP4QfMC3uChfA'
    b'9tFq+2i1XbS44FtNB5blomGxV8ty0OCE0NI82DabmehIASThGpCQZQ5mkUAP54MeAXxgdKao'
    b'gFjwYxOfCSoTeqbZhaCbyOVM5HIG8nkT2ayBXM5MEIAQ/tj8V1UFuq5EVoTw+UUAUQQTgbgW'
    b'YKHjF8E68N78kDKzn4YBKPUBGsQEQH3mCpAAhIQsLgAWHwAnAFCKEKLoR2QAWHTf81iQz7YD'
    b'5gbYzPy3BAlYLhoNB3XLRqOhIdNw0Gg40e9VVYZie7BtD64bwPcJfBLOExvoWQEfFD0COGfM'
    b'H4kWgsj8eoWb9ioXegO5nIFCIYN8PpN6zeVi4RckIWIAwtyPswDpiP/sGoCFC4DSp0L5GYQx'
    b'EYQBQAUBsI1QH4AMQgMAASSEAAlBeIaARNdCpA/TtQWiBsDzQ3ieCAYGaNvM3G8KAsjbyDc0'
    b'1HMOslkb2YyGet2GoStoaA7UpgRFlmDLHhzXB/EAnwAIFnIJejgX9AjgnDB3fXzS1I8FX4u0'
    b'ej5voljMoFjM8i2HYjHLScCMTP5MRoOuM8EX0f75hJ6l+9KVgZ3Hdc7nw319SkOAElarH4ok'
    b'vARCJYBKYPEACaBICf0sa6ijsjAMWRUgm+evwDOYW+A4Kuysj1bWQy7nImdpyOUc5HIOslkN'
    b'2YwN01RhGMzyYcFSnh61JUi2B5cE8IhIXVKEYa9w6HzQI4CzYnZduiQJrT9b8PN5E/l8BqVS'
    b'DqVSFn19uejnYjGLfD4WftPUo9hAUtsvLPTnXva74DlRCkDiFgBJyHOiSJ+GnCQoSFQbgNlK'
    b'lqZJKFlspFA2tixUKQJdhueFMHQVpucjY6rIZjTkMhpyWbZlM2zLmCoypgrDaEPXZGgqr4Ow'
    b'eAmy5IG4PjyPIPA5kYXJRqO5DrSHTvQIYF7M1vpJP1/45YahI5vVkcuZKBQy6OvLo68vh3I5'
    b'F/1cKuUi018IvmkK/z6dy08X9ZCUto+O5PykPpEWIJGgiwVM2cZMfDZmLgRFQvgFMZAEEUT7'
    b'6rhSnE9kwnoDZJkgpBRyyMqINY1C82TomgJd82EYCkxThZlhQdKMqcI0VJ79UKJN02SoovhI'
    b'lCDDhwcAARAgZHw1q4y4RwLzoUcAc2IurU+iAJ+mKTAMDZkM0/hM8JnA9/fnUS4XUC4z4S8W'
    b'cygUWNDPNA2YpsbN/FjwYy2frO9PHMEcAn9eJECS5jofIU6BSOBpCCAAQQjKX8Xv2Htc+KPd'
    b'cOGfY4w3ESTD85ESIZAIBZUo5JCRgqpKUFU5JeSGzkx/sbH3ZehJN0COg5+iYQnRsgSswahH'
    b'AueGHgHMwtzRfZHSMwwVpqkjlzNQLGZRKuVQLufR31/gWx7lcj6l9Vlkn/n5scbvDOala/hZ'
    b'fj3dDQjEKTzP86LN9314nhcV8ySbeoQlwSwMGaqiQFVZZkFRJSgSi+gTUBAiWvMCFvgTG0Ju'
    b'Lcyl+ROvHdePgvCAIXulBCCU8ArDuMw4qjBUJWgaE3Zd48SgKdH/VVVmx6wkCp/4xlhArJzU'
    b'I4FzRY8AIsxl8hNu7rOUnhD8QiGDUimLcpkJ/cAA24TmZ75+HN0XqbxY8JNpu7m6+FgtvxD0'
    b'VqsFy7JgWRaq1SpmZmYwMzOD6elpVCoV1Go1WJaFVqsF27bh+340uZfVCyjQdR2ZTAaFQh79'
    b'5T4MDPRjaLAfg4NlDJQLKBWyLBipEagSIwMSWQvC9BeXSgiceJXQERQAE//YbaAgsSuRIAIi'
    b'8XSmFEKWpLjnQBRNqTI0jf0/IoDOysfUfVuIBHroRI8AAMwl/JJEUtH9TEYIfg59fTku9EUM'
    b'DhYjzc+0fha5nIlMhuXxRcnuQg07ydy94zio1WqYnp7G2NgYTpw4gWPHjuH48eM4efIkxsfH'
    b'MTMzg0ajgXa7PceI74UhSQSmaaBYyGFosB/r163Gpo0bsPmKy3DFxvVYt3YVBvqLyOdM6KrM'
    b'TG3hKnDBjYSeSACRERNA0grgMQX+SvjPVBADv+Yydw1CIoFIBLLoOuQNT6oixX0PqgxFjrsQ'
    b'42uXuIPR5CEANESYurU9K6ATPQJYwOQXlXsiwFcuM00/OMgEf2CgiIGBAvr68iiVspG5Lwp4'
    b'WCpvdlAvWSrM1glsYmJiAsePH8ehQ4dw4MABHDx4EO+//z7Gx8dhWclFMs8fkkSgKgpkifn/'
    b'ruugXqthYnwMihwi9NuwWzW0m0MYHCyjVMjBNHSoqgxCJGbIE+HfSwBR+JYkAXFNeRaBiExC'
    b'AGYVBKwOIWlhIIQk8e5IsQnLgBNCtEmJAGDkFiHKXIg0ZAhWHyDai9P3u0cCAj0CSIAQRHX7'
    b'uq4imzVQKJgolXLo72eCPzTUh1WrihgcLEWBPqb1WXRf1Op3Nujwb4DEG+fb7TZGR0fx7rvv'
    b'Yu/evXjrrbcwMjKCEydOXDCBn+MMEy3ILB6g6ToMw0DGMGAaOjRNhSQR0DCA7/vwAxmSTKDI'
    b'QsOTWPMTBSBqggTEZxIEQANOAgFAgkRdQZxpIGCERAiNOiaJFE8hYk1HEmQ+m4DwKUQgiYwl'
    b'5VOIaHrACGjAKgYB9OIBs7HCCSBOiwm/XAT6cjlWxFMuC8EvYdWqEoaG+iKznxX1mLyCT+0Q'
    b'/LS5TwhBEASYmDiD/fv344033sDrr7+Ot99+GydOnIDjOAse6YVAFLOTEkQgSfGEH0WGqjAz'
    b'O1luHHvZCRJAggQkFYDCiEF8ltJY8JEMKAoi8MEyDoS7BbG7IKyB5PWTiASZxAE/8XeiByGe'
    b'b0D5lCFR1MT2GfSCgnNihRJA2uwXKT5VZSW8+Xys9YeGSli9uozVq/uwalUJg4PFKNCXy5m8'
    b'mEfB7L78+CH2PA/Hjh3Da6+9hh07duCNN97A4cOHYVnWJT9zwsU5mUIjXLCi12SZMfsj8U/i'
    b'3wQJQJAAjwsAiC0AnkqMegz4RqToZ4IAAOHWAPtbIoKFkNkxC/eJkIiQkrMNAt7YxMaQJUed'
    b'CXuklxmYCyuQADqFn/mWLLevI5830deXxcBAEatW9WF4uIzh4X4u/CWUyyy9l82ac2h9Edhj'
    b'pOJ5HkZGRvDCCy/gueeew549ezA6OvqBA3cXFonI/qy353E7zuqNJMlAimWMAFFhEZU5IQgi'
    b'kMEi9mJjRMD+jC8mCr5Lvk9BPqzQiGt+PtvA9ykbL8bHjAV8DqFYxJSG7FjC1MKkPaxAAmAQ'
    b'JrCI9JumjnyeFfQMDhaxenUfhof7sWYN0/6Dg0X09RW4yR+n9uYy94MgwP79I/jNb36D3/72'
    b't9i7dy8mJycX+5QBcG0YjehObJH5nJ4N2BlAS0fxOzckMgTibwjz+4nMTX85JoBokxgxhInp'
    b'wgiiXcgyACLFhghBqv2YdR2GqTmDns8GiqSGjvqEeSUXJb6yNLGCCCC+6UL4WTkva9fN5zMo'
    b'l3MYGGDCv2ZNP4aH+zE83IfBwRL6+nJRlF806yS1viSxiP7Ro0fxq1/9Cr/61a/w1ltv4cyZ'
    b'M4t3yh0Qwi8EIuTDQHxfbH5iYi8zqcWA0JS5HJUGh3GkP/LhOaL8nIyofJhKjAQIbzKKhF8C'
    b'QomNIKasoIdQ8EwBswZkCYAiQRMEEfLxY8muQy+INpfPD/CDeOBoTGw9N0BgBREAQ1L4TVPj'
    b'kf4MyuU8BgdLXPOXMTwsND8Tfpbb16NhHHGjDnt4pqen8Zvf/AY//elP8frrr2NiYqLrNE1y'
    b'9DcbBxbA9wK4nsc3H67nR9WFITehw5BV7oniHkooiEjtUR+gSuzrJ0uFCYlliyYqBinlsQKR'
    b'PpRYhxXlBCBWC49kk8UGZAksY6ASUIMipDoz/4OQDx8V3YZsEpHn+pFFIOICNGTH30sNMqwQ'
    b'AkhG+9PC39eXDvYxk7+MoaESBgaKUX6f1fArs0p4fd/Ha6+9hieffBK/+93vcPLkyUX28RcC'
    b'z5HzWYCeH8DzPbiuB8dx4TgeHMeB63rwPB+e78MPAiihjJBKkKIKP9ErIAJ5Htf0XJhFTCCZ'
    b'PYiIQIqJACEjCUqYBRClGVOHzI0JHheQAFkBNCqzJGKoMQvAYyPIXD6HkG0BHE9MHQ7g+xKC'
    b'kIIiQBD04gDAiiEAQJjposAnkzES/n45CvYND/dhaKiEcrmAUonl9w1Dj4Q/OeDz9OnT+MlP'
    b'foIf/ehHOHDgAFqt1mKf5IKI+vTF8E5fjOxy0bZdtNs22m0HbduB47hwXR+6FiBQQkhSCCLH'
    b'QstMc2EBSEDoJdKAJGEF8KyAGFIoGpKoFAs/Idz8Z7uHBBYPSBx3NH0IsTugUxmhqUZWgOsF'
    b'sN0gNX3Y5mTguWxOIXMHJEikVyUILGsCiLU+gERpL/P5S6Us+vsLWL26jLVrB7B2bT+Gh8uR'
    b'8LNIvx6V88ZFPRKCwMfLL7+Mf/iHf8B//Md/YHJysuvM/fmQNP/ZlB4XNhf+ZstGi29t24Hp'
    b'uCzYqcTkJ8sSN/dFoI5rbynhxwtBSpJASvjnIAgBibsA4lXshoLFD8THZEChMnQKhKZwAwK4'
    b'Dh891nbZ/MFo4nAAR5BAQEFDsnDmY4VgGROAAI16+DVNQSajRT4/S/P1Y+1atq1aVUa5nEeh'
    b'kElF+pP+frVaxc9//nN8//vfx759+y5JAc+FhCAAPwjg+T4c10Or7aDZsmE1W2hYLeSbbeRa'
    b'NkzDgK5r0BSW6iQSAaGEuQJE5OyFFcCj/SFhGlwgsrQFKZBYoqNAYUfWgBULAhJFrKZZUQ9B'
    b'yIOKhI0qh4QwVJANKDwv5CPHPLRaHqymB8ty0WypaLU82I4CzwsQ+CFCEhslKxnLlADmivir'
    b'UaqvXM5jaKjIfX6m+Vet6sPAQB6FQpYH+9SOSD9w9OhRfP/738e//uu/YnR0dMlo/SSiwhnu'
    b'AjALwEaz2UKj0UQ9ayHP5xSahh5ZAJIiQRJFThKJJgRRhCDE5+Z7UngTX0rA3pjzcglCSMYG'
    b'wIWf7yekou4PAGUNSTw4wAq4KAxDQc7X4LpsDQKrxaYN1xs2mzpsuGi1JDhKoo14Vppz5WEZ'
    b'EkBa+JOanxX5ML9/1Srh9/dhaKgP/f0FFApZZLNGlOYTmj8IAuzevRuVqRCZAAAgAElEQVTf'
    b'+c538Otf/xqNRmMRz+/DIbV6j+fD5RaA1Wyj0Wihlm0iW88gkzEZAWgqVJWToSTxKTyJlYcA'
    b'3vcfAPASQstfoxRiMkjI/zJSwZ0kIANQ+X5EmpFlHihoIh5AIYFAkWVQFTBMBTlXQztnoJj3'
    b'UC84yNcNZGo2DEOBpstQbBmyHID4IRKRyYt81bsXy5AAGJLCLzr6+vryqaCfSPP198dmPxN+'
    b'JZo4Y9s2nn32WXzrW9/CK6+8As/zzv7lXQ62gg/L+7ueB9t20Gy20TCbyNQNZEwdpqHD0DXo'
    b'mgZVU+MhHLx+mFlWzElPxtOjgD3X3ODpQ5bYl5Of6kAnCYD9ncRTi2EIED6lKOomZJ+RZSCk'
    b'EjRVgWGqyGY15PI68jkduazGW7NVaKoCRfFS04RS378CsYwIYLbZryhsdBcT/s6IPzP708If'
    b'm/2EAI1GA08//TS+9a1v4e23317Ec7uwEG4AW7zDh+24aLUdNKwWDEOHYcQEoOksCKrIMmRJ'
    b'TvcIQOb1AWFcnw9BAjQuACIJIoisAR4zABKmvxBCif8t7zMgIS8gEtOJwqgZSPytLAOqKkHX'
    b'2XzBbEZjRJDR2XBRnQ0XUUQjFK/aJFFNQC8LsEzAIvWKIkez+UslUeFXjgJ+q1eXMTDAOvqy'
    b'WSPq3xcTeGdmZvDjH/8Y3/nOd3D06NHFPqkLjmgdPy+AK3to2zaspgJN4yPKdfaq6So0Ja58'
    b'FI1CSVlh040CxE23fJCoCOKJSkESggk0TwOCFwRFPj0SxUKiUChE3HosGomCKHoXUQYhfLyY'
    b'DENXkTE1ZDM6MlkNGVODwQewysp8k4TYka80ElgmBJDW/qy5h6X7ikWR7uvDmjUs6Ld6dRmD'
    b'gwVe4cdaeZMBvzNnzuDJJ5/Ed7/7XYyOji7ieV08pLIBPB3YatlQFQW6JtYnYFkQVVEgR+RI'
    b'0gV+4PV8RGK1AvxdShBZAUQKYl9eEuXDMtsojwuQjiChGDkG3i9AeAxBlBEj5ANVRDKBDR5V'
    b'ZBmqpnBLQIPJF1rR9ORkJpLqXF7JWAYEkO7uYyv0yNzvZ809IuI/PCyEv4i+vjxyOROGoUNR'
    b'FEgSm847NTWFH/zgB/jbv/1bjI+PL9pZXQrQkPJ6ADEkxGEzAcTqw0pigRIRAIxcAJHC4zuT'
    b'mVZPB/+5yS+EPxoMErJEPhREXYQ0WUTUkZ+LrITk6DESK2weSCS8HEFVpGh1JsPkKy1pChRV'
    b'hiQI4GJe2CWEJU4AaeFPV/rpKJUyGBhgU3zioF+RN/aYqfJeWSaYnp7Gv/zLv+C73/0uJiYm'
    b'Fu2sLiQ6x4cnU5cU6YyA7biQ+bQgMRRESQ4G6TD/RSKQudByVNrPJvvwngHRQUhFQI8PBQm4'
    b'SS8lNDwS1YEitCjG/cRnhFh1x9OGAbAaBQmQ+QTniAQMNopdVeJ5DR0RwBWLJU4AAoSP85JT'
    b'+f6+vkJikk8pIfwZmKYeVfjJsoRqtYof/vCHy0b4CSHQNA2apkGWWfRdTBl2HCfuV6BsmAYJ'
    b'fBCXz+OTJa4p4zkHEp8JGAXfeFkxFR2DVGPuAKU8fYpY+Hm9AMIQJBXQ8xkRJEmAEqQnC3Gr'
    b'gYpuwwVSdrxMW5bA1xvgKytHi6yqUGSZpzJ7AJY0AaQfBDG+m43zMlAqZaMBnqKxh83vm93S'
    b'22w28bOf/Qzf+c53MDY2tkjnc2FhGAbK5TKKxSJ0XQcABEGAZrOJ6elp1Ot1NiwDAGiIIAAI'
    b'fDggceUjEQuVIKUxkx2FYuBGSCl0Shmp8s+x4CDP4Qt7gYYgyTgA+GyAaM6g8PETUYbUIJFk'
    b'63GcfIxsAkL4eHEFqqZFGQ2dFzUpigJJZkNO01iZlLCECUBAjPQSdf4GCoVsYohnLPxpzc+C'
    b'Wq7r4plnnsHf/M3f4MSJE4t9MhcEkiTBNE0MDQ3hk5/8JC6//HJIkgTLsrBz5064rotWqwXX'
    b'dQEkioN4VZ/jiEBfZ75cDBIJ2RbGWxDGY7hUlQKKDAoKiXCzniTaiSnv86c+1/qJAF80ViwZ'
    b'CxBWAJsc1Dl7QBQjicAhkVlakC3PrsMw2cBW5gow4ifJngV+bvHeVg6WKAEkmJ8g1eIrqv2E'
    b'9h8YiGf4JXP9bIBHiF27duLb3/42Dh06tKhndCHBMiEKcrkc7rvvPtx7772QZRmTk5M4ceIE'
    b'jh49GrkFApS7AqKgL1WWi9gVF/P3REtxIIaK8NfADGGEGihVoIQKZJlGTVRMPlkpL40ieCHE'
    b'TMA4IyCEX8QBAGYphKDRcFGxUlGykpB9j0QIZEWCqlEYJlt2PZM1YWZYZ6eobExaKPzKXbR7'
    b'0q1YggSQNv2Z8MvRGO9iMYP+/jyf2V9Ef38+lesXqSBCCPbv349vf/tvsHv37iVZ1z8f4om6'
    b'LA5gGAZkWUYul4NhGDzr0WkC89RgEHIOYMIQGeIJAgjDECGfwuP7rKnI80M2UcgP+BJlGjQt'
    b'hKIofCEP8KIh3jDE1w1k5b1M45Mout+pnYFosVKxajEQr1EgWoqFBcDXDlBVAt0IkMmayOUy'
    b'yOUyyGQNmGZcFej7JDEboFcHsIQgAn9xzp8F/vKpFXtKJRHxT3f2jY+P4+/+7u/w/PPPIwzD'
    b's3/dEkXy3FRVRSaTmZcAADZbH2EI+D6E9qUQBCBM/oAVEfGOQrZGYRC/+j4804RpBNB1FaGq'
    b'QAkpDygKiyAWWNZZSDgRAEmfXoDRswg4hvHnov1IzK+nzL+XZAmKKsHQKbIZjy/LnmGTnDMG'
    b'dN2G2nbhSgGPY1y4a76UsMQIYK7Anyj3NaIe/6TpP7vMl6DdbuPJJ5/EU089Bdu2F+lcLj0M'
    b'w0B/fz80TYOqqpAkaU7yC0Pmd1OfCz7EKLEwMU8g5IuSMgJweWOR67JXL+fD8wyYvh4VFjFr'
    b'IK4olEi8YhITYjFsJF4zKNloQCnLJlA+2w+EgMhKigRAJBCiQIIEVaHQDYJM1kc+n0WhmEOh'
    b'kEM+Z6GWaaPVcuC4PsJQSkxxWllWwBIjAIFkzl9BJqOjUMiiXE6b/qWSMP21yO8HCH73u9/h'
    b'Bz/4AWZmZhb7RC4pFEXB+vXrkc1moes6ZFme1/phAzT571xEaT9RNyCaiTwxU9Dx4Touby92'
    b'4DgOck4WWYcH4HRGwppYJDXqtkwWGDH3RfT6EULSwk9ZWlEQUBiECFQKXTdBIIESGazPQIYE'
    b'GbJKoGoyzEyIfCGLYjEXr99YbcGybNiOB9+PsxkrDUuIAJLlvrH213Wm/dOBP2b6s4U7tMjv'
    b'VxQZIyMj+Pu//3scPXp0xd1wQgiuuuoqDA4OYmxsDI1GA77vz3sdRL8AINwAsQpPiJBPE/Y8'
    b'nxOAB8d10LZZY1HbdlBoO8jn2BoKmYwBU9ehGyo0VY3Ki6MViKIOQ+7HE0ECHd8tSpi5xRG2'
    b'bBSKMkwzF2l/QAGRZO4eyjBMilwuwwigj5FApdpEvWHDtl02ADWU+LmurFjAEiIAgeSy3Wqk'
    b'/cVwT7FYpxjpFUf9ZTQaDfzTP/0TXn31Vfi+f/avWoa44oor8NGPfjRag9B13SgdOBcECYh5'
    b'gmwNPjZbLxrD5QVwXY93Fbpote3UiLGYBExuDWh8zoASpWRlmS1TllxINQruA4lFQGLXw7Zt'
    b'tG0XzbaHtesM6EYWlLLGIUJkSJCgqBSGAWSzGRQLNkolRgLFioVarYV22+ZDUMMVGQtYIgQw'
    b'W/uzVl8FuZyJUomZ//39hdSyXbqenOcH/PrXv8YvfvGLJT3Q48Mil8vhM5/5DA4cOBAtL16r'
    b'1eC67oKWAHMVWCqA1QAkRouLuQKOi7btoN1mgm81W7CaORRybLJyLmsimzFhmgZMg3cb8tiA'
    b'yt2CNAmkCSAI+SBTz4PjeGi12RAT15tGECq44sqrQCQVgAwCha8uDGgagZkJkI+Wd8+jVLJQ'
    b'rTZhWTbabTYANQgklmZkZ42VYAUsEQIQiLV/vJoPW8ePEUA+ivqLwJ8w/d977z388z//87Ip'
    b'9jlfEEJw7bXX4rHHHoumGGuahnq9Dtu24XnenEQg/P/YEmBEEI8XD6Lx4u22g2arHc0YbOSz'
    b'yFtZ5HMxCWRMAwa3BuLYgBI3HiVWVWY9C8lBph7afIhJvdFEpdrATKUJM1fGug0bgZCA8sVK'
    b'ZRlQNQLDDGM3oJRDX18OlYqFer2FVsuGw2MBItC5UrAECCCt/cVyXvHy3RmUSln09eVRLKaF'
    b'X0yxcRwXP/nJT/D666+vWNNfgBACwzDwqU99CqZp4qmnnsL+/ftRrVZhWRaazSba7TY8z0MQ'
    b'BOnmIaaKEVASpePDIJ4vyPoM+Ihxm1kBDauFRqOFfL4ZEUAuy0aOZUydL67KJw8lXAJRigwS'
    b'k4/v+2zmH29dtqwW6g0LM5U6jrw/CqJk8dn+YeRyRVZpDJZtUBQCXQu5u8g6RPv6cigWs6hW'
    b'LTQaLbTbDjxv5cUClgABxIh9f5b6YwSQZX5dKZtYtDMd+Hv55V34xS9+seKi/vOBEIJcLod7'
    b'7rkHW7Zswa5du7Bz504cOnQI1WoVzWYTzWYTrVYLjuPA87woWxAH5AIWkaeiFJhpaJEOdGwH'
    b'rZaDTLPFxo1ZTPCzWQO5jIlMllkBzB1gdfqpLIEsxxYAZRaAmGHYtrmFYbVQbzRRrTUwPV1D'
    b'td7GmnWX49ZP3slKfXl3oCQT9syYOnI59swwSyCLSiWDWq2JZpNZAZ7XrYu6XBwsIQJIm/9i'
    b'yGexmEWplEWxmE20+Ko8sCSjWq3ipz/9Kd59993FPoGuAiEEuq5j06ZNWLt2Le666y7s27cP'
    b'r732Gg4cOICxsTHU63VYlgXLsqLegYgIKHhwMNEYlMwMuCImoEVEUDdbyGbYzMFMRhAAtwI0'
    b'lXUvRq4AK+xhc0XoHATAx5g3mqjXm6jVGzh+Ygz9A7/Dps1bMbxmHWjABpRIEoUSrQNpoFBg'
    b'caMoJZiz0Gi0o1iAWA6NYXlbAV1OAHOb/5rGWn5zOROFQgaFQiYy/cVoL1lmZPHSSy/h2Wef'
    b'7fpVexYDItpuGAbWr1+PNWvW4I477sDx48exZ88evPHGGzh48CCmpqZQq9VQr9dnEYGoF4iD'
    b'gunAoIgJtFoaDKMNy9B5Yw6fPWjqMHWNty4rUVAwOY6dJqL/rutHgcZmi40zt6w2rFYbtZqF'
    b'/3j2eVy3/UY88sijUcefJFHIMo36Rdhzw5RGscienWpVh66zjIDvn0Pr8TJBlxNADJEjZua/'
    b'imyWCX+xmOUsbnJ/kvn+iiJjamoKTz/9NN5///3FPvyuBoly8BIKhQKuueYaXH311fj0pz+N'
    b'ffv24cUXX8SePXtw+vRpVKtV1Ot1NJvNKGAYb4Sl6vioMWENONwa0G0HTU3lMwdVaNz313U1'
    b'jgEoyZWXmQDTjvSf47JJxm3bYasY8bqDVtvGzKHD+P+eeQYfu+FGbNp0BWjIyowliaZWhmLB'
    b'4yyPGzErwLLaaLcdyLKPMCSJ+MfytQK6nABEEojwDjcZmiZz7W9w7W92aH+JN/tI2LlzJ3bu'
    b'3LnkVu9ZTAgyUFUVq1atwn333Ycbb7wRe/bswe9+9zvs3r0bp0+fxszMDGq1GmzbTrgFNFqF'
    b'N04RypBlH64nw3E9qHxaj6aqUDUFmirGj7G6AEWRoUQTiKRo4lcQhgj8uPfAdT3YPOvAipA8'
    b'uC5LQ77wwg7ce+/L2LDhMt71KFaHklOl40krgM2GZO6j63rckknUIS9TdDkBxMIfR/81ZDLM'
    b'/BcNHizwpyeKSmRMT5/Bv//7v/e0/3kirsQjKJVKuPvuu3HttdfixRdfxDPPPIP9+/dD0zRU'
    b'KhU0m83UisgxERCEEoUfSJD9AL7swxOjxhQXiizHMwfl+DWqDOSz+6Lio6CjByF6DeB7bCXj'
    b'MASOHz+B3/zmt7jttk9i48aN0eBQWQQDeQCZxZCYC5nLZZDJWLAsFbYtw/PYvpZ7RrDLCQBg'
    b'fd8i+h/P+xP+fy4Xa//kiK/f//73eOWVVxascuvh3CDIYHBwEA8//DC2bNmCn/3sZ9ixY0fU'
    b'WdhoNGYtiy6IgBAKGgJBwCYHS5IfDXGReAWgMPmTNQCMAAivOQBolG3gswd4R2IQsA7FMGDV'
    b'gpRS7HzpJezevRuXXXZZiswUReqwAjI8gMwyFIahodlUIEk+CAmXvRvQxQSQHPoRR/+T7J3L'
    b'GcjlDJimBl1XIt+/Xq/j+eefx+HDhxf1DJYjFEXBRz/6UfT396O/vx/PPPMMJEkCpRSWZc0i'
    b'AYATAQUIWOutGC4q+QFIQuDZaPHE5OHk8FFRhIQQNKAIotZkGpXwilgEABw7fhzPP/88brvt'
    b'NgwPD3MrIG4iMwwNmYzBLUkThYLJCUCFpilwHAm+nxhOukzRxQTAMDv6zwgglzO59mc3TWh/'
    b'0fDz8ssvo91uL/bhL1usXbsWX/7yl6EoCp566ik+DMRHq9Wav6QYTEgRUBDCZgGBhFEXYFLw'
    b'iWgEiP5YEACN2oFZpk4EIGd/30svvYSRkREMDw9H3yGepaQrIJ4lYQGwSdEyJMlf9m7AEiCA'
    b'tPlvmukbJvL+wpd0XRevvvoqRkZGFvvQuw6e52F8fByO40QrJrOVgHQYhgFN0+YdFDIXBgYG'
    b'8Nhjj6HRaODf/u3f4Lqss+5cgq5CmFMr/JDY3Tjb3zLBX/hzBw8exKuvvoqPf/zjKBQKEQkI'
    b'RZF0J9nG6hKSi8N2zh9cbuhSAkib/yz9J26YMN2MDsZmDULHjx/HK6+8gunp6UU9g25ErVbD'
    b'j3/8Y7z//vvR4NBcLodSqYT+/n4MDg5iaGgIAwMDKJfLyGQyZxXIoaEhPPLIIzhx4gQajQba'
    b'7TZ835/TFVgIXKYvaB2+67rYsWMHHn74YWzbti1laTCLUlgBevQ8ZTIaknMjO9coWW7oUgJg'
    b'YOY/SZlsaeGPRz2LIZf797+DvXv3LvKRdyc8z8N7772HN954A41GA5RSKApbD9A0TRQKBQwN'
    b'DWHDhg3YvHkzrrzySmzatAlDQ0PRaPG5sHnzZtx///14//33YVkW2u1217hfb731Fvbv348t'
    b'W7bw8mLwACRTGMyq1JHJsC1+puKl0BI9iVhugcAuJwCS8v/ZYp86Z2o9Yf6zz7RaTbz55ps4'
    b'duzYYh9614IQAsdxUKlU4LpulB9XFAWqquLw4cPYvXs3CoUC1q5di61bt+JjH/sYtm/fjvXr'
    b'189JBIQQ3Hzzzdi1axfGx8dRr9fhOE5XzFqcmJjAa6+9hrvvvhsDAwOglCaCgSKwrPKSZBFQ'
    b'1qBpcmQFLOc4wBIggKS5FjO1qPpjTT9sGx09jTfffHNFzfn7oKCUddUltbQgWrGkuqqqqFQq'
    b'mJycxKFDh/D666/j2muvxR133IFbbrkFq1atSsUKCCHo6+vDXXfdhd27d2NmZgaWZXVNAdZr'
    b'r72G06dPY2BggGt0GlkBqipzC0hHJqPxMmV1gdHhywtdSACzx36Lyb+mqUXCn1zkgVX+AYcP'
    b'v9cL/p0HWL4+4P32HmzbRrPZ5MusmajX6xgbG8PBgwexf/9+3H///bjmmmugaVq0D0IIrrvu'
    b'OmzevBmnTp1CtVrtGgIYGRnBoUOHsHXrViiKEsUBYjeAuZeiMSkZV1rucYBzD/leciRHf4mF'
    b'HjW25LOp8fbRePXadruF/fv34+TJk4t94EseghBs20atVsOZM2cwPj6OkZER/PKXv8T3v/99'
    b'7NixY5af39fXh+3bt0frD3QuPrJYmJ6exp49e2BZVmr4aKd7KawAURIcK5e5VhBaHuhCC4BB'
    b'5P/jFCBjadZFpnVU/smYmJjGO++80zXBp+WCMAzhOA7vxGPzA23bhmVZCMMQd9xxBwzDiFYj'
    b'uvbaa1EulzExMQFZlj9wNuBiYc+ePZiZmUFfXx+S2SVWGShzAhBWgBa5l8I1Wq5Tg7vWAmA3'
    b'CFHpZtICYEGaOFcrSQSjo6M4ePDgYh/2skUQBGi1WpiZmcHk5CT27t2LH/7wh9i7d280ZYkQ'
    b'gvXr12N4eBi6rkNRuke/jIyM4NSpU6wSkSt0YQWoqsiEsI0pmrg56QOURiw5dPGpkUQHl8wX'
    b'emSmmjD/Rd1/EPg4duxYL/p/kUEpheM4qFarmJ6ext69e/HUU09hbGws0o7FYhHr1q2Dpmld'
    b'RQBjY2M4dOhQFJcQFoAoCtI0sZx4HAMQU6XidODyQ5cRQOcAkDgGwPw0pv1Z3X/cPdZut3H4'
    b'8OFe8c8lguu6qNfrqNVqeOWVV/D666/DcZyojXjt2rXR6kPdIjiO4+DAgQNotVqz4gDpZ0zl'
    b'/QCxi5leIXl5ocsIQIB03ByZT4tRohsjcrSyLKFWq+Hw4cNd42+uBIgA4dTUFHbu3IlKpQKA'
    b'CdXg4CA0TUvN9esGjIyMpEbCz7YCFE4ESirDJBYrSSyVuhiHf1HQlQQQs3P65ohN5P6FaTY9'
    b'PdMz/y8xwjBEu91Gq9XCwYMHcfLkSQRBAEIIisVi5AJ8kN6Ci41jx47hzJkzUTGQQPI5U5Pj'
    b'yeX0GgXLEd1zdzoQuwCiSk0QgJyaGUcpxdTUJEZHRxf7kFcc2BhwB9PT0zhx4gQ8zwMhBJlM'
    b'JgoCdhMBTExMYHR0NDUangm3FGWTVJVtyRRgXA68/NA9d6cDSRdA+PvC9Gc3i/3e932Mj4/j'
    b'zJkzi33IKw5sUi8rHJqYmIgsgG40/wGg0Wjg5MmT8DwPgLA0kyQQB55FgDm1VNkyRFcSQLI3'
    b'PDbNOkZG8fys57k4fXoMlmUt9mGvSIgKwmazGdX+d6uwBEGA48ePd0yJIpG1KRROUvjjASVY'
    b'lm5AVxIAgMRNIZF51umXSRKBbdsYHx/vBQAXGckiGdEOnJzQ0y0YHR2dNSYunoocP2uxFSBW'
    b'LF6e6FICIImbIiVujBT5/sJ0a7fbmJycWOwDXvEQNfaU0mjtgIWWHl8sjI2NJapFScoNiDsj'
    b'pXlcgOVHBF1JAOmbQlKCLzZxQ9rtds//X0QIoTFNMyIAsdpwEARd0RKcxPT0NJrNJgBEz1Dn'
    b'cybay0WmKVY4i3vsFwNdSQAMJGWaCR+tMyjTbLZQrVYX+VhXJliMhmVl8vl8VDM/MTER9Q90'
    b'mwVQr9ejYShArGzSMYDYCpg/CNhd53W+6FoCEIEXxr7SLOEXfd2tVhP1euOs++vhwkMQgK7r'
    b'KJfLkGUZnufh1KlTcF133qXGFxPNZhONRiNlmSQVTVL7J2MAy9UN6FoCADCHBZC8GSzwJIpR'
    b'erj0YHlzFblcDgMDA5AkCdVqFSdPnoxiAN0Gx3EiAkia9aL7dHYmID2ifLmhqwmAIQ74ERL/'
    b'H3zBCNu24Ti9CUCLAUEAg4OD0bSdEydOYGxsLHIBug2e53WMLo8XDYmfs7TWF8/bckSXE8DC'
    b'F51SGpmaPVx6sBV9NWzcuBGlUglhGOKdd95BpVJBq9XqSgIIggDtdjvlmiRXDlqumn4+dDkB'
    b'xDcpXvwhngdPKYXneb0agEWAoigwTRP5fB7btm2DaZqoVCrYu3cvLMtKLRraTRBKI0kAyecp'
    b'3hbpAC8xupwAkLohyZ8ZU1MEwQefQd/Dh4cYJS4mB2uahgMHDuDIkSNoNptduyZjGIZRdoJG'
    b'6xDEP7OlxihfdowtPbacSaGrCUBc+PiG0Fk3pNuizCsBkiQhk8kgm81i+/btWLduHRzHwa5d'
    b'uzA1NYVms9nVblnnMyOeoyCg0QrEYhPPHdCrA7ikmFv4k4wsTLflO62lWyFSf+vXr8edd96J'
    b'UqmEkZER7NmzB7VaDa1WqyvNf4HO54U9Z0zY2fLjAd/Y/9MLjy4vhdOVBJA295nQMzZOan+2'
    b'wGQ8u72HSwVR/LN69WqUSiW0Wi0899xzOHnyJOr1etea/wCiNRFFHYkAswDipcd9P2BLjies'
    b'zjSWh9LpnqFtc4BSJIQ/NsliNiZ8bFN3jJ9eKRBtwEeOHMEPfvADrF69Grt27YrKbLs5JkMI'
    b'ga7rkRWQtjRpZAEk3QAh/MvR2+xSAkjfFCH8bKMpv0zX9dQCFT1cfPi+H41hm5ychGEYaDab'
    b'qFQqsG27q+MysixHY8wBRK5kbG2GKRJgCicE82i697zOF11KAOKmhDxqK25IkLgxzAXQdbZI'
    b'aA+XDmEYotVqwfM81Ot1SJIULSTSzdofYNmLbDabchuFsomDgELpJGNNy0/4gS4lgKRZJm6K'
    b'7wfwvIAPoBDMTGCaGWQy2cU+5EuCeEhKslMt7o8Qgay0n3tx0FmE1c1aPwld15HP53nnIiBW'
    b'/WXu5lwZgKTbucgHfxHQlQQAJFk5Fn7PiyOzQcDuRibDlrVezhCLduq6DsMwIrdHzNwT2ow9'
    b'wGwQh/i9aNG9WFgqgi+QzWajzkWh3cMQiSyAsDRDxIHn5en/A11KAPGNoYkbEvDlqXweoWWs'
    b'bJoZvtzT8oMkSTAMA6ZpIpvNRluxWIzq74vFIgzDAMBGdVcqFUxNTWF6eroXG5kDpVIpYQGE'
    b'UQqQKZpY2SRjACzetDwZoCsJIBkEDIKQa38m/J7nR/GAMKQwTRP9/f2LfcAXFGKwZi6XQ6FQ'
    b'QLFYxMDAALZs2YLt27fj6quvxtq1a1EoFKIBnOJBdhwHMzMzOHToEN5++23k8/nFPp2uwsDA'
    b'ALJZ5jKmFU3S0vTh+35EAsvV/Ae6jgDi3GwyKuv7AVzXh+t68DyPxwKYuWYYBoaGVi3uYV9A'
    b'iOk6pVIJ5XIZw8PDuOGGG3D33XfjmmuuQV9fX2qJawCplFYul0O5XMamTZtw++23R7GCHhhW'
    b'r14NXddTtSbiGRNKhimagLtTybRzuoNwOaDLCCCNpAXguh7f0laApulYvXo1FEXpyu6zDwIx'
    b'WadcLmPVqlW47rrr8MADD+Dmm29GoVCI6h3mC+4lCUGSpGUfGzkfrF+/HrquI7Yy47Sf63pw'
    b'HI8rGvGMUe5uLvaRXxx0LQHMDgL6cBy2CYb2/RCZjI7h4WEUCgXMzMws9mGfN1RVRaFQwMDA'
    b'AC677DJ86lOfwsMPP4zLLrvsrII/H3ol0mkoioINGzZEsZH4Gf+WpD4AACAASURBVEs+Xy4n'
    b'AT8RBwB6MYBLDGF2MQuACb3jeLBtF47jRgwtSRKGhlZhYGBgyRKAqqpRYO/qq6/GY489hs98'
    b'5jMolUo9Ib6AKBaL2LBhAxRFSTQAseAfe75c2LYHx3G5FbD8YwBd6xx2Bmccx0O77cK2HU4C'
    b'zEwLQ4rBwQGsW7dusQ/5vKAoSqT5r732Wnz1q1/FQw89hL6+vp7wX2CsXr0aw8PDPGgaJlzM'
    b'WLm02y7abQ+Ok8w2dW9j04dF1xKA8NE6b1Cr5XIiEGZaiFKpjMsv37jYB/yBIUkSstksyuUy'
    b'tm7dij/6oz/CPffcg0wms9iHtixxxRVXoL+/nxdNxea/0P5JBeO6XioLsBwDgEBXEkB8gWMT'
    b'jd0kxtAOWi1xk3x4nodcLocrrrgCqqou4nF/cBiGgWKxiMsuuwyPPvoo7rrrrp7wX0RcffXV'
    b'yOfzs1LMsfZnzxZzAWILoIs7mz80upAAYohGIBGhZTfIRqtlo912Il9N03Rs2nQFBgcHF/uQ'
    b'zxmKokTTdO+55x7ce++9Fz1nn2ylXmnIZDLR6DLR3suCf8KydNBsppULI4DlWwQEdDkBCKb2'
    b'/TDhAsQ3qt1msQCAYMOGDUvKDdB1HblcDtu2bcN9992H1atXX/TvtG07mtW30khg7dq12Lx5'
    b'M1RVjeJLTPszy5I9U0yx2DaLLyVLgZcrupoAAJGnZWmamABiK0DUBqxatRpXXXXVYh/wOUEU'
    b'+5TLZdx8882X7LhnZmbQaDTgeV5XT+y5GNi2bRvWrl0brV4kqv5s24ueKcuy0WzakQWQnAWw'
    b'XNGlBDA7DjDXzWJszdKCxWIJ27Z9BLlcbhGP+9ygKAoMw8CGDRtw3XXXXbKCnWPHjqXW7Vsp'
    b'IITghhtuQF9fX2K+BHMrbVs8T200m+0oBpBsO1+uAUCgawkgRjIQ6DhJAmhzEnBh2y4URcXW'
    b'rVuxYcNli33IZ4WqqjAMAxs3bsT69esvyXc2Gg0cOHAA1WoVruuuKAtAVFVmMtmo608E/1ot'
    b'hz9L7UipsBSgvyJcpSVAALG/xgKBbuKGpRl748ZN2LZt22If8oIghEQz9desWYNyuXxJvvfd'
    b'd9/FgQMHUK/X4TjOsn+wk7jmmmuwefNmKIocxZQ8z0e77UbKpNFowbLaiRRgPHVqOaOLCUCY'
    b'W0mTzY9MNnHDhBXQbrsYGBjE9u3bu9oNEAM9TNNEX19f1Mp7MVGv1/HCCy/g2LFjsCyrq4d2'
    b'XmgQQnDzzTdj9erVcxSWiWepjUajHQWWRQUgs5KWNwl0MQHESLoBIg4gbpqwAtptB6qq47rr'
    b'rsfGjd2dDSCERG7AxR5oGoYhdu3ahZdffjma2b+S/P9169bhxhtvRKFQSJj/IvLPhL9eb8Gy'
    b'bG5N+lEGIG0kLT//H+h6AmDLMYtxTcJvE0HAWq2Fer2FRqMdZQSuvPIqXHfd9Yt94GdFctTU'
    b'xcS+ffvwy1/+EkeOHEGtVuv6oZ0XGjfccAO2bt0KWVYShT9+5Puz54dZk+IZ8v3l7/sLdDkB'
    b'0GhLlm222y4ajRbq9SZqtSYajRaazTaaTRv9/QO46aabsWpV984IEAM0RUT+YuHgwYP48Y9/'
    b'jN27d2N6ehqWZa0o7Z/JZHDHHXdgeHhNNFmKaX8nof2bqNfZ88PMf39FRP8FupwAYsTpQC8y'
    b'3+r1JqpVi5MAqw0IQ+CGGz6Obds+stiHPCcopfB9H81mE6dOnUKlUrko3zEyMoInn3wSL774'
    b'IsbGxqLo/0rCRz7yEXziE59AJpOJVvsRFaVM+zdRqzELstl0eINZsCKi/wJdTgDJegAkTDhB'
    b'AC3Uak1Uq03U680ol3v55Rtx6623duU4LLGicbvdxqFDh3D48OELun/XdfHGG2/gH//xH/Hs'
    b's89idHQUlUpl1pLYyx2SJOGOO+7Eli1bUrUkLItko1ZrolKxUK02IxfScbyo/n+5B/8EupwA'
    b'kojrt0X+tl5vo1ptolJpoFq1Il9OUXR88pO348ortyz2Qc8JZsXYOHr0KHbs2IHTp09/qP2J'
    b'+v5KpYJnnnkG3/ve9/Diiy9idHQUMzMzK074AeDKK6/EXXfdiXK5n8/3E5WkTHFUq8J6ZM9N'
    b'0vxPX6vla/4DXTwQZC6IHK7rBrBtVg8gmLxSsdDXl0M+n0E+38a2bdfg1ltvxcjIAbTb7cU+'
    b'9BSCIECz2cTMzAyee+45DAwM4JFHHomamc51DoAQfNu2cejQIfz617/Gjh07cPLkSUxPT6/I'
    b'oB/Art8dd9yB66/fDkIQPTMsdtRGtWrxZ0b4/6z8l82XWL7jv+bCXDkogrlpj3RsMgBJVTf/'
    b'se9jHbtoF5st2f4liZl4sixDVRVomgrD0GCaOjIZHZqmolQqQFUVvPXWW5icnLzIx/XBIeb3'
    b'+76P0dFR1Ot19PX1IZfLzRri2TnbX6xxb1kWDh48iKeffho/+tGP8PLLL+PUqVM4c+ZMFGBc'
    b'acIPsL7/r3/967jxxhtTFaS1WhNTUzWMj1dw+vQ0xsdnMDVVQ63WRKtl8/r/AGnz/9JZAIoi'
    b'gdLpfWFYGQfgAnAA2PzV4e95AAIAwk+Z7waf04EvAQsguYor68wSI5zabVYPUKsxRp+ZsVAq'
    b'MSsglzNx/fU34Pbbb8fRo0fQarUW8yRmIQxDWJYVrejz85//HG+//TZuuukmXH/99Vi7di3y'
    b'+Tw0TYsaWDzPQ7PZxJkzZ3DkyBHs27cP+/fvx+nTp1Gv11Gr1aJKv5UU7U9CkiTceeeduPnm'
    b'W0CIBM9jjT2sdqSFatXCzEwDlUoDtVozqv5Ljv+KsbzNf2BJEACQJoE4ks6Ynfl0jAAa6OvL'
    b'oVDIIps1sGpVGZ/73APYtWsX9u3bu3iHPw+CIEC9Xo+CgrVaDe+++y6efvppDAwMoFwuI5fL'
    b'RROPW60WKpUKZmZmUKlU0Gw20Wq1os22bfi+vyK1vsCVV16Jz33ufqxZsyYaIc+yRixeNDMj'
    b'CMBCvd7kxT/J4J/A8hd+YMkQABCTAEUYsoxA0gpgfl0DMzM5FItZ5PMGMhkD11//Mdx77304'
    b'dux91Ov1xT6JWQjDEM1mE47joF6vwzRNTE5O4ujRo3NWCQrz33Vd2LYNx3Gi9t6VLPgAm7Fw'
    b'33334ZOfvA0AjUbJCSUxM9PA9HQdMzMNVKtNWFZn6+9in8GlxxIigDRYQDAu6azVmpiZaaBY'
    b'zHICMJHJ6MhkynjooS/g1VdfwauvvtK1QiIi1e12O7XwZyeEoLOVkXpCn8Q111yDhx9+GEND'
    b'Q5FZ326zbJEQ/jNnGAHU6000mzbX/p11/ytD+wNLjgBmWwGsq4v5d5WKhUKhjkIhg3zeRDZr'
    b'wDR1bNmyFQ8//AUcPXoEExMTi30SC0KUCPfwwdDXV8KDDz6Im266KRojzzJFNmo1KyKA6ek6'
    b'KhWL5/5F5D9YkdofWFJ1ALMRj3XyIiuAsXwNZ87UUKlYqNVacF0fn/vcg7j11tt6C2YuQ0iS'
    b'hFtuuRWPPPIIstlctIaEqBadmWngzBmm/SuVBvf97Wjy70op+50LS5AAkm3ClMcCvKg/oFKx'
    b'cOZMHVNTSRJoor9/EF/+8h9j06ZNvXn7ywwbN27EE088ga1bt0UTfZnp30Kl0sDUFFMK09N1'
    b'VKtW1EI+d9ffysISJIAkaNQlKMy9apVZAVNTNUxO1jA9XUO1aqFeb+HGG2/BF7/4OEql0mIf'
    b'eA8XCPl8Hp///Ofx2c9+FmFIE81iLDDMNH8NU1OMAGq1Fvf9/cTQj5Wp/YElSwBz9QjEsYCZ'
    b'GYsTQDVx4y2EIcGjjz6OO++8q+cKLAMoioJbbrkFX/nKV1Aq9UWTo5vNduQOTk6y5+DMmTqP'
    b'/LO8v+8z7b+ShR9YckHAuRAXBwm/T9OaMAwVmYyObJZVB5qmDk3TMDCwCl/96tfw/vvv4+23'
    b'9/UCbksYmzdvxte+9jV85CPXRMNhWy27Q/grmJqq8cj/QjX/FCuRBJZYKXDn4cQ/x/eSgBBA'
    b'kghkWYKiiHJhVjKsqjI2bNgA09Tx1lt7YFnWJTzmHi4UBgYG8PWv/z/40pe+BEmSo3RwtdrE'
    b'mTM1jI3NYHR0mpf8VjA9XUe93kKr5UQEsFglv/OhVwr8gRGnBZkrEPCqOgmNhgJdt2CaemLT'
    b'oOsK1P+/vfMOsqs+7/7n3N52792qlbTqlZWQBEJCBVRiLJCQkTGiKIaYTAy2wRk7kh0PeGLH'
    b'mcx4xokJxpmJE78O4Q3vmLhgAjY2xRTZCDUjob6oS6vte3sv57x//E67d3elFazQSnu+M2du'
    b'O/2e5/t72u95nA5uu209J0+e4sc//hGpVOpyX4iFi4DX62XDhg088MADeDxevUeEcAIn6O6O'
    b'0dUVoatLjP6RSIJEIk02m7McfxW4wgnADJEboE3+SKWyOJ0O3G5topBLJQAnTqeD+vog99//'
    b'F5w7d5Zf/ep5isXi5b4AC0OA0+lkxYqVPPLIl2lqGqt39E0kMkQiwvfT1RWhszNCd3dUHflF'
    b'2M9y/PXHVUAA5fMESiXFFBXI4HIZJODxuFQzwIHDYae+fgxf+MIj9PT08Pbbb1lZdSMcNpuN'
    b'+fPns2XLFlpaWtSOvqK6jyb8nZ0ROjvDdHVF6O2N6Sm/IuOvOKqKfQwFVwEBwECmQD4vqbFg'
    b'u64JuN1OXC4nLpcDu92G3W5j2rRZ/PVff5VYLMaePe9d7guxMAgkSWL69Ol87WtfZ/ny5ZRK'
    b'sin0m6S3Vwh/R0dYn+YbDhvFPrR8/5Fm919uXMFOwMExcDlnCZtN0nPsNQJwOh1MmNDM2LFN'
    b'HD58mL6+3stwxhbOB0mSaG5u5rHHHuPTn74Tu92hN/XQRn7h9Ovl3Lk+OjoEAUSjST3ff2C7'
    b'f2Q8rxouhxPwKiKA/sfW/nBROQe0eyVJEpJk0yMFLpeTSZMm09jYyKFDB4lGh79Qp4UPj6am'
    b'Jv72b7/Bvffeh8fj07v5RqNm4e/j3LleOjrCdHfH1Iy/jKnQZ6WsjCzhBysKMAww/AFmU0CS'
    b'JGy2NHa7oQEIbcDYsqEhxOrVn6RQyPPEE//M6dOnLssVWChHY2MjmzdvYdOmTfh8fr0grDb7'
    b's7s7SmdnWFX9hd0fixkj/5Ui/JcLVxkBmKGgKJJKAiIvQBCBpL7X1pP0uQENDSE++cl1yLLC'
    b'U089wcmTJy/b2VsQI//mzZt54IG/IBCoNk39TtPXl6Cryyz8YTXklySR0HL9S5bdfwFchQRQ'
    b'XkJMTBsWoUEA8zwgSTIW7XN9fYjbbluP3W7nhz/8F44ePfqxnr0FYaKNHz+eLVu2cN99f05V'
    b'VTWZTE7N8kvT1xenqytKR4dI9OnoiNDdHdOn+WoFPvuXRbOEvxJXIQFAJQmI58CI8wuB10b+'
    b'8odCUYQmcOutt+PxeHjqqSc5eHC/FSL8mCBJEtOmTWPLlq/xmc/chdfrU1vCZ4jF0oTDcX3k'
    b'P3eul/b2MN3dEcLhhOrxF+29DKef9b+dD1cpAcCFSEBLGS5f30B9fZA/+7M1+P0B/vVfn2TX'
    b'rp1WstAlht1u59prr+XrX/9bbr31NpxOt97DLxoVwt/dHaGjI6KO/kL17+2Nm+b4F0f9HP+L'
    b'wVVMAHA+Ehi4JICIFiiKqDVQXx9kyZKbqK6u5kc/+lfefPONEVdd+GqB2+3mpptuYsuWr7Fs'
    b'2XLApjaBzeg1HoTwGzZ/V1dUneNvTvaxhP9icBWFAQdDfxVf8w3IsqIusrooeuhQcwza7TYm'
    b'TJjAvHnzKZWKtLW1kclYJDCcCIVC3HnnZ3j88ce54YbFyLJCKiVy+7XaDh0dYdrbe2lr66Wj'
    b'o4/Ozqg6zdsQ/ivd6WflAVxSlNcQEK+KPtprHWG1RVHKbciGhkauv34hwWAV7e3tRKMRyy/w'
    b'EWG325kyZQqf//xDfOUrX2Xq1Onk80WSSa2Ul7D329uNJJ/2dm3kLy/seaULP1gEcAkhVbwa'
    b'moCosCsEXpZltY20oleK1TQERVEIBALMn7+AKVMmE4vF6O3tGXUdd4cLXq+XJUuWsHnzFj77'
    b'2fupqalV8/pFjL+3N1Ym/GLkD9PdHSUcTlZM8ClSKl35sX6LAD4WlJNAuRag6H3ki0Xj1TAR'
    b'ZOx2BzNnzmL+/Pk4HA56e3tJJOKWNjBE2Gx2mpubueuuu9iy5eusWrUam81OKpVRZ/SJAp5d'
    b'XaJ9V2V6r+btT6dzgzj84Mp4DvvDIoCPDQNpAqgagKz3ki8UxFIsGpqBRgSNjWNYtGgRzc3N'
    b'ZDJpwuEwuVzusl3RlYBAIMCNNy7hS196hM9//iGmTJmmN3aJx0VyT3d3VE3t1dT+Xj3Dz1zO'
    b'Wwi/VtXnyhd+sFKBLxNEdEBRiiZtQFYJQJSX1qadptPiVSx56uqqWbPmdmbPnsNvfvO/vPLK'
    b'b2ltbSWft4jADIfDwYwZM7jttrXcffc9zJ17LbKMnrKrFfDUHH6imEdUr+kYiYhinsLZJ4R/'
    b'4KYoV67wXy6MUg0ABooOCOef4RSs1AQKhaKqEZR0U0GWFd1BOGvWTNxuN4lEglgsNurNAptN'
    b'RFDWrVvHl770CJs2fZaJEyepjTpTxGJGBR+tY69Z5dcKesRiZmffYNN6r6Rnb2BYGsDHjvI8'
    b'AVFctKSHCEslWZ1LIDSBTCZPOi1SUlOpLKlUjlQqRzqdo6YmwPXXL2XmzGtYvvxmXn/9FbZv'
    b'f5e2trOjjggkSaKpaSxLltzIunW3s3LlasaOHUsuVyQcjuujvtaxR+vjIEb8qNrAQzj6RA1/'
    b'w96/0j39Iw2jnABgIBLQesRr9n6xKOvmgChBlSOZFB7rZDKjL6FQhpqaAJ/4xK0sWHA9u3fv'
    b'4K233mTXru2cOXPmqq9ArOXwL168mFtuWcPNN9/MhAmTKJUUotGkmtWX1Ru4COEXNftFI5c4'
    b'4bAY8ROJNKlUTh/1ryZn30iCRQBAZVkx4ReQy0wCzRTI5wUJiPz0rO7AisfT1NWlSSbTVFcH'
    b'CIVCrFmznhtuuJF9+/aybdsf2LHjXU6cOE42e3X5CJxOJ1OmTGHp0qWsXLmKRYsWM378BEAi'
    b'kcjoGpO4VykikSR9fQlTGzch+GLUF407MpmcGuITplb/vH5L+IcDFgHo0B6ogUwCzRzQNIGi'
    b'TgLJZIZEIk08niIWS1FbW0VNTYp4PKV2Kg6xcuUtXH/9ItaubWX37l3s2LGdgwf309fXd0Wb'
    b'BzU1NcyZM5elS5eydOky5syZS0NDI4qCahply0hStHBPEg7HdQKIRBJEIik1oy9DOp0jl8vr'
    b'vhbh7AMrtffSwCKAfhjIJJD16IDmHDQ0gaxOArGYGN1qa6uorQ0QCgUIBpNUVYmW5fPnL2bO'
    b'nPnceus6WlsP8957u9mz508cPXqUeDx+OS96yAgEAkybNp2FCxeyaNFirr32WiZOnITfX0Wx'
    b'KKsjfk4nR03wo9Ek4XCSSCRBOCyWaDSl2vkZUqks2Wy+zNa3VP5LD4sABkR/k0CWQVFKZREC'
    b'zS+QTufVTrRpotGUOtIJAqipCRAM+qmu9qtty32MGzeZCRMms2zZzXR2tnPs2Afs2/c++/fv'
    b'4/jxY/T19Q0wl/3ywGazUVNTy7Rp05g3bx4LFlzHNde00Nw8gWAwhN3uIJcrEIkkdCepltQT'
    b'i2mjfoJIRLyK+2MW/Jza1cfw8Pcf9S1cKlgEMCgGMgkkXRswNIES2WxBL09t1gSCQT+hUIBQ'
    b'yE8o5FeJQJBAVZUPv9/DlCmzmDp1JitW/BnhcB9tbWc4evQDjhw5zPHjRzl7to1IJPyxpRw7'
    b'nU5qamoYP76ZGTNmMHv2NcyePZtJk6bQ2NhIIFCF3e6gUCiRSuXJZoXgZzI5dfZeVjWHjJE/'
    b'EknqQh+Pp3VVXyT0lDv5xKhvvu/m/8LCcMMigAui3CQATNqAZhIUdZPAnNkm1N4EwaBP9QcE'
    b'9PfV1T4CAS9+vwefz4PP56apaQLjxk1k4cIbyWTSxONRuru7OHeujTNnTtPW1kZ7+zl6enqI'
    b'xaKkUimy2azqJBv6aOl0OnG5XPh8PoLBEA0NDYwbN46JEycyadIkJkyYRFPTWGpra/H7A2oj'
    b'VUkX+lwuqTfk0JyhWiREc4jGYmKkj8WE4CcSQs0XXXzy5HJFvWqPoe4b97j8/lu4VLAIYEgY'
    b'2EEoFlmNEhi+AU0wEok0Pl+KaNRLIOClutpHdbWPYNBHdbVf1QQECfj9bjwe0b7M43HjdvsY'
    b'M6aKceMmcd11iyiVihQKOTKZDIlEgng8RiwWVZc4yWSCTEa0vyoWC7oJYbPZcTqd6r59BAIB'
    b'qquDhEIhQqEQwWCQqqpq/H4/Ho8Xp9OJzWbXE6MKhSLpdFrPiNS0HWPEF+q+Jvwa+SUSQhvS'
    b'7HstezKfL6o1+o3UagOW8H/csAjgotDfNyCchEZdAREqLKmJQ4aQ+HxuIhE3gYBXF/yqKkEM'
    b'YvHg9RqdjEUnI9HRyO12qQ1NvKpfYYyporGijv5CkAxNwFwCXdJLoWtl0CSpvDO85tvI5/Nq'
    b'1mOBfF68ZrOFfolQyWRWt/XNJKB9n0oJkshm87pzT1P1LcEfObAI4KLRXxsA+hFBsVjUnYRa'
    b'Ewu324nXm8bnS+L3u3X1X2gAHl34fT6DCIRGIEhAdDay43A4cDhs2O12bDab+t5oeGIIvFH7'
    b'QOQ0lHQnmxbWNCc7mSMcWvajkfwkIh6Gyq9lQ2bU16w+V0Jr1a2p+VpKtTbt2rBWLMG/3LAI'
    b'4EPjQkSgqdBGtMDptKujpxO326U2LdXUc7fawLT/q8/nVknAqbY5F70NHQ672uHIrhOCWIxR'
    b'X5xTeUKTJvxaqnPlvId83hB8jcA0tV8L8WlLJpMnmzU8+ZqKbxzHGvFHMiwC+Mg4HxHISJKY'
    b'ZixJJQoFG/l8kUymgNOZw+m0670Ktb6FopGp0czU8AsYvQ2dTiH8WpNTh8OmkoFBCjabuQiK'
    b'Uha5MAReVmsemAmgqI7+eZUEtNmQef29JuzZbEHVFgp64o4xdVrWiWfgLD4rsWckwCKAYUMl'
    b'EYj3WtERkHQ722Yrks8Ldd3hyGG3G8LsdIr3ZmIQi0PvbKwRgCbwTqdd3Zf4rPVArNQAtFFf'
    b'E3ZN7TdrAWLGY1Efyc3mgGbHa7+b96OZEkLN1/wS54tMWII/EmARwLBjICIQn4UQgixLSJJM'
    b'sSiRz0t6j0JjMVR6IfAOlRjsJtXfXrGNzTT62/ROSGA2AWQTCRiCX/m9EGpj6rMxBVruZ0Jo'
    b'pdSEhq9cIBxpCf1Ig0UAlwyVD7shGMYIKdaTJCgWza3LbGWkIJx7dtNnqUzQNeef9n25598o'
    b'fabVODQ7/8orIxtaQrmj0LyNVj/RrN1cKAfBEvyRCosAPjacTzMwwnelktAORMsyqaKnoTGy'
    b'a4v5d/OrVNH4wLDHFV14tao6lcVQxHey6b2xjXa+H7EOhYURAosAPnYMrhlonw3HmUYImOL3'
    b'6CN75WdN6M2/g0Eu5krI5tHbSGpSBlh3oHO80DVZuFJgEcBlx1AIwZzgY2xj7nBsfBYe9oE0'
    b'gPLPxrHKfxpqSrEl9FcDLAIYcTAL1mDCWCm4AwnycMMS+KsRFgGMaAwkdJd6iqwl6KMJFgFc'
    b'cbAE1MLwwXbhVSxYsHC1wtIARhRExuCl27f5VUP/vokWRg8sAvhQGC5BVUyL7SL3eTEVc8R0'
    b'YUmyqcU9KAsFFotF0zlYGE2wCOCC0AS0hBA0G8MjKGK/ojCIl76+hFoufChdbjThlxnaCK7Q'
    b'0FDDnXfexOzZE7HbJT2zL58vcuTIWV58cRvRaBKLBEYXLAI4L4SQ1tRUMWfOJGRZ4cCBU8Tj'
    b'KT56OyoFm83Ghg3LuOmmufz4xy+ze/eRIexTnJPP52H58jk4nU5efXU3xWJpkG3FcTZuvJnN'
    b'mzcycWKjmh5sVDxua+vB5XLw9NO/U9tsW+bAaMEoIoAPM/1UweGws3btYrZs2UhXV4R/+Idn'
    b'2b79AAO3Vbw4uN0uFiyYxurV83nhhW0XtW1DQ5AvfnE9hUKJ7dsPEQ7HGfjaZGpra1iz5gZq'
    b'agLs3HmETCavzxuorvYza1Yzd965nP/932309EQH2Y+FqxGjhACMklmGiju0h9zpdDB9+niu'
    b'u24a+/efxO12MjyxeAWHw4bHI2xyrR3ZUOHzeZg0aQw9PTHsdtt5tlXw+VzU1ASIx9N8//u/'
    b'YP/+k2hpxGPH1vHEE19g7Ng6AgGvSgBXKsw+FXMfWwuDYRQQgILT6WDVqnkUCiV27DhMJqO1'
    b'5rrQwyGRyxV5++33+d733LS2nuXQodOc304eihCL49rtNpxOuz7l1tj+QmSl6KXAtMaZ5duZ'
    b'H3wbkUiSU6e6mD9/KjNmNPPaa7tIpbKARHt7Ly+8sI3a2mrC4UTFscwCVXn+lcI10HUP9vtQ'
    b'sh0HWvd8EPtpaZnMtGljee+9Y5w7183FO1dHF0YBAcg0NdXw1a9+hmg0RWvrWTIZ8fAPaWu5'
    b'xPbtB9m37wNyuRKZTJHBHyrxENps4Ha7cbudyLJMMpnFbpfw+TykUjnV664RgENvOWazOWlp'
    b'mUhzcz2FQokDB07R3R0ty+N3OOzMnz+DDRuW0dAQQpYVHn54HblcAUmSOHz4DO+8c5BUKqOf'
    b'ZyKR4re/3cWqVfO5994VvPLKbvbvP4GiQCZT4Ec/+jV2u414PF1xLQpVVT5mzmymsTGELMtE'
    b'oymOHWunry+OMdJq1y3h93tJpbJqCbD+vxsTjiT9GMInMRApSKZ99L/Pld95PG42bFjGZz6z'
    b'nG9/+/9y7lzXoP+rBYFRQAAKHo+T+vogkiSp6vJQt3Mxblw99fVVeDwu+voSHD/eTjY7UJMO'
    b'8VB6vW7WrVvEpz61lMbGEOl0jtdff4+urghr1y7i2Wd/z9atewGDAAqFIqGQn0ceWc+DD65h'
    b'/Ph6isUSr7++h+985785dapLP0ZNTRWbN2/k9tsXEwh4qK+v5vHHN6EoghzefPN92tt7OXDg'
    b'BGYN4o039vDuu4fUc1vCiRPtJJMZFAX6+mL6embBHD++mR2AjgAAElpJREFUnoceup17711B'
    b'KBRQCSPHa6+9x5NPPs+RI2f165YkhYULZ/Hww+v4yU9+x86dh/UiIQDTpo3llluuZ+fOVvbs'
    b'+UA/1qxZE6mu9tHaeppstsj48fVUV/tJp3OcO9dLOp2lnAQM4bfZ0OsdyLJMIOBh6tSxBAIe'
    b'crkCF9YuLIwCAhDQCmIMbcKMWGnx4tl8+9v3M336ONxuJ9u3H+Zb33qGffuOIZyA5Q+l2+1k'
    b'06ZVPPbYJhobQ0iSaK21fHkLPT0xqqp8bNt2iK1b9wCSXsGnpibAl7/8aa65ZgI1NQESiTSB'
    b'gIc771zO9u2HeeaZV8hmhdZQKpXo64vppcZTqSzd3TE0ITl5spNoNGW6FnGOPT0RfvGLrSxZ'
    b'cg0bN97Mb36zg337jqtCWhlKVAgG/Xz2s5/g0Uc/hcfjIpXKIknQ2Bji/vs/QSKR4Z/+6X/o'
    b'7o4AogjJwoUzWLt2EX/84wF279YIAJxOG0uWXMPmzRv5wQ+eZ8+eVvUYVTz00DrmzJnI00+/'
    b'wrRp47jjjqXU1wdJpbK8/PJOfvjDF+joCFMu+BKNjTUsXDiDhoYg8Xia1tazKIpCQ0OQvr4E'
    b'4XCs4posDIRRQwAXD4V8vkB3dxSv18306eNobm4gEPAy0MgiSQrz5k3lK1+5E4/HxU9+8juO'
    b'H29j5syJ3HvvSubOnUxbW6+pOq6iV++ZPLmJcePqOHu2h+9+9zm2bn2fRYtm841v3MvChTP4'
    b'6U/fIJstABLRaJLvfvc5Dh06w7e/fT+/+91u/vmff6FX6wmHE/T2xiiPUojR9s033+eddw6y'
    b'fv2N3Hnnco4ebSOVqvSHGLb0ffetIpXK8YMf/IqtW/cDCkuXzuHhh9exfv2NvPjiu3R3G07D'
    b'6mofTqdd9UkY99HpdNDYGCIQ8Jj8FWL9iRMbWLq0henTxxMM+ohGU/T1xWlqquWhh9bS2nqW'
    b'5557g1xO+EgcDhvXXTedzZs3smLFtTgcdhRF4fTpLvbuPc7kyY0cP95BJFLpz7AwECwCGBQS'
    b'u3d/wBe/+CSTJjXyne88yMSJjaYWVhVrSxLLlrUwdmwd//Zvv+aJJ35OKpUhFKomHI7zN39z'
    b'F4oiOu1o0JyAAIcOneH73/85L774LvF4knQ6zxe+sJ6qKh82owsIsqzQ0xOhvT1MqSTT3h7m'
    b'4MFTem0AQ8OpfPglwuE4P/vZ2yxb1qKG/d5l796jJlVdbON0Opg9eyLjx9fz7LO/54c/fEHN'
    b'fYC9e4/T3FzP3XevZPz4OhwOu5qDYMPrdetmglnTcjhsBIMBisWSmmwkjuX3ewgEvASDfnK5'
    b'Ai+9tJ1nnnmV48fbueOO5XzrW/fT0jIZp9OhE0BzcwPf/Oafc8MNM3n55Z28995Rxo2r49Zb'
    b'F3H//bdgt9vYuvUAsVh6gHtgoRIWAQwI8eAUiyVisQThsJdCoaibEQPDRlNTDaWSiMsnk2lK'
    b'JejtjfJf//UqLS2TufHGWSYCECaAx+Pi2LF2/vEf/x8vvfSuPnoqCnpJ8X5nJ0m43Q5sNknN'
    b'HpRRlAv5NsQ1bd26nz/8YT8bNixj48abaW09Y9ICQIzYdhoaqikUShw6dJpYLI72qMTjGXp6'
    b'Yur9KCccn8+NLMuk0/kKArATCgkhj8VS+rlo7dJOnerkiSd+yXPPvUVPTwwo0t7eqxcn1Zyg'
    b'DofE3LlTWLx4Fr/+9Q6+8Y3/QyyWwOVysm3bIf7+7x/g2mun0NkZVq/JIoALYVTlfQ6tgKUZ'
    b'Roktm82m17ofcE1JNN2UZYV8vlgmANFogmPHzqkagBHuczhEX4ATJzo4ePAk+XwOzXOv1fYz'
    b'avGZjyWp+QOS6pA0e83PF/uWiEYTPPfcW/T1Jfj0p5cxZ84UU5sxAYfDjt/voVQqkUxmTb8I'
    b's0X7LZ3O6gQlzslNsSirpGTA6XToo7ymSQD4/YIA3nzzfX7+87fo6Qnr51ld7cdutxGNJvVj'
    b'2O02JkxowG63sW/fCSKROLJsI5stsHXrPn77211Eo0m6uqLk84Xz3AcLGkYZAXy47bSsOa2S'
    b'rkB/FdvpdOj9Ac2w24XAlkrlJoDW0EPU2JfL9qnV9S+V+msANpvYnyRREZEYLG5fniDzzjsH'
    b'efPNvYwbV8c996zA53OXretwCCEvFEqqF96A02knEBAaUSqV0wnRbrfh87koFktkMoWy/WkE'
    b'oHVO1q6zqsqHx+OitzdOKpUvu/7qah82m0Q0mlLNLkE+Y8fWUizKFY5BRQ29ukgksqpjsvw/'
    b'sDAwRg0BGOWxZUTCTOUyODuIirySXiZ7oJFFkoRAi1CjpO9XkqC5eQxz506mVCpVEIBoBqK1'
    b'yS4/pk0/ZqXWoWkAikKFBqAlAykV35mThCCRSPPTn75Jb2+c9etvZP78GaoPQVO1hQaQzxdM'
    b'BGD4B0SYragmVGkxfuEDEG3QzCaAmLdQV1etN0pVr5Bg0I/TaScaTaqmj5G8VF3tR1EgFkvp'
    b'fhe73cHYsbXkcgU6OzUCENc7fnw9s2Y1E4+n1GxGKwQ4FIwaAgDw+VyMHVvHmDG11NdXEwqJ'
    b'mXher0stoml+aLSHq6RX3BUdcIpAkUrSUBSFvr44breT5cvn0NhYQ3W1j5aWSTz66AZWrZpX'
    b'kfGH3tVHa7ZhhmYCiO+Vit/A43GiKAqZjKYBKPj9XiZPHkdNTTXmUb+uLsiUKeP1tGNFgZ07'
    b'W3nttT/R1FSragGesvPy+YQGINR5g0Q8HheBgI9sNmc6tiA/r9dFPl/Qt5EkhaamOm67bRFT'
    b'pzYRjaZM/gYboZAfSRKRDTMxgkQw6KNUKhGPp00EYCcUCqj/pQeXy4nP52bevGk8/PB6Vq2a'
    b'R3d3VJ0XYWUADgWjwgmoKFAolGhpmcTjj/854XBC7XibI53OE4ul2LWrlW3bDpq8/BKNjSGm'
    b'Tm1i6tSx1NcHcTrtzJw5gVQqR1dXTLWPxfqyXOLtt/excePNPPzw7TQ0hIhE4sydO4V16xbr'
    b'GX/CYy6gmQBCAyhvnikSlqR+moEQLAm326U2+9QICRYtmsWDD67hxRff5fnn/6Cf24YNS1m5'
    b'ch7f+97POXjwGCCRSiV49tnfs3r1fD7xiQVMnTqW/ftP6EeRJPD7PTQ01CAEScw2bGmZxJQp'
    b'Y+jsDJNMava88JG4XE40U8jjcTF16jgefHANDzxwCzU1AaLRpG6yOJ12gsEAsqyoar6hWTkc'
    b'dqqr/RQKRRKJjK5NFItFTp3q5JZbruPRR+9g5szxVFX5WLq0haVLr6G62kdXV4RwOIkl/EPD'
    b'KCAAiXg8xcsv72TBgukEgz7GjKnB63Xr/faKxRI1NQF27DiijvDCbr/pprl885ubaGgIUldX'
    b'Takk83d/9wBnznTz1FMv8MYbe3WTQFHg3XcP8e///msefXQDX/rSeux2G9lsniNHzuJ2O/uF'
    b'AS9sAqD32jNfj6JALpfH53Nz/fUzOXasHZ/PzaZNq1i79gZ27Dhs2o+defOmsnbtYvbtO4Xf'
    b'L4hDkiRcLicdHWFmzmymoSGo7z+dznHyZCd33XUT999/CyKdOE1tbRX33beaSZPG8Mtf/rFs'
    b'5mCpVCKVytDQEORzn1tDZ2cfK1bMY/XqBWSzorFoMplRM/Qk3G4ndXVVyLKsOgZltNwFh8NO'
    b'MOgjnc6RSKT11OFMJsfPfraVqVPHcuONs7nuuunkcgWOHTvHM8+8TlNTDX/848GySIOF82MU'
    b'EICNnp44Tz31An6/aLXt97vx+70EAmJxuVycPNlRNjorikJ3d5S9e0/Q2BhSRzUnPp+H+vog'
    b'gYBXFVBtC4l0OsvTT79KV1eMRYtm4vd76OqK8v77x7n77hVcc83EMhNA9POzDeIE1KIA/Z2O'
    b'uVyR1tY28vkCf/mXa1i9ej5Op4PJk8fQ2trGgQOn0ARKlkucOdONJMGXv3wHd999E7KM7quY'
    b'OLGR7u6oKaFHIhZL89Zb73PHHUu5444lLFkym0wmT3W1j6oqL6+++ideeundslh7NpvnD3/Y'
    b'z+rVC9iyZaPqDMzx2mt/orW1jbvuuplz5/r0eRAAqVSWgwdP097eV/aPlUoye/ee4OTJTjo7'
    b'w6YmKQrvvfcBjz/+NEuWXIPH4yIcjnPw4Cna2noJhfwkEhmVZC0CGApGAQGICSjJZFpVWSu9'
    b'5Oapo1p6r2iFtX37IQ4fPkMg4MHtduL1OvF63ciywrFjHRQKlR56G/F4iueee4MXX9yGw+Eg'
    b'l8tRW+vnnntWIMtmE0CiqyvC66/v4cCBUxVxa4menhj795/i8OEzZduAQrEos3v3B/z0p29x'
    b'zz0rmD17AoqicPZsD//936+zZ88xDPeOzO9/v4cVK+axcuW1NDaGTN1/hN/iF7/YysmTnfrx'
    b'FUVh9+5Wnnzyef7qr9bS3FyP3W6jpyfGyy/v5Mc/flmdFWmEHEulkj6r8LrrppPPF9m79xgv'
    b'vLCNXK5IR0eYbdsO6fc7k8nzq1+9w2uv/YkPPjiHYbMLLemZZ17RMxvNKJUUWltP09p6qt//'
    b'F49r2X+W/T9UDHSXzDNCBvpeq4nlBOw+362vZLPKjcJ2vhJv+oWmqVZ61TVoZFG5TYlKB+Gk'
    b'Sc38x3/8DaFQgM997nscOXIKsONyOWhqqiGdztHbGzedg5iING/eVNraeuns7KP8/irYbBIT'
    b'JjSwbNkc6uqqkWWZU6e62LHjsDq5xxAou93GDTfMZMGC6Xi9Lj2sJsuCAN5+ex/t7b0YpCF+'
    b'9/u9tLRMYty4OhQFUqkMR4+eo62tx2Szmx8VhUDAR0NDFcWiTE9PjGw2iyTZ9UlPgnu0bbT7'
    b'ZKP8XlZOiR7KbMAr8dkzQ8HtdlAqtT5bLJ7YAySBOBABYur7JJAGckCB8odtIHm9YOLLKNAA'
    b'LoTBk2YEhlL5xwiFTZ8+nrq6KrLZAplMDkmS+OQnb6ClZSJ79hw35ahL5PNFzpzRZvoZAisS'
    b'fHLs3HmQgUc0kSB0+nQnp093Ikl2QFFDnP33VSrJ7NhxiF27Wk3XppjCopoQmrUhIfC7dh2q'
    b'uE5NUzIHkIxzE5pW0nQedhQFU2KO+ToG3odxjMFwpQv7yIFFAMMGhdraKh57bBNz506mUCip'
    b'8XCF6dPHoyjw0kvb1VRX8+y7ygf9fL9VricEyHASVhYQkcrW1Ub+/sI2UPbg+QjwfKRpnNf5'
    b't7GEeCTAIoBhg6RW2S1QVSVSXL1eNw6Hnfb2Pv7zP1/h+ef/WBbuutD+hmedynU/zDYWrlZY'
    b'BDAsECp1NJriu9/9H5555nV1ppsHt9tFd3eEvXuPmwp3WoJlYWTAIoBhg6Q64to5daoDkRwj'
    b'VaTzWsJvYWTBIoBhRbn9K8tKWWahJfwWRhosAhh2WEJu4crBqJoMZMGChXJYBGDBwiiGRQAW'
    b'LIxiWARgwcIohkUAFiyMXFzyskYWAViwMPJxyYjAIgALFkYePraChhYBWLAwsqBULJXfDyss'
    b'ArBgYURBqSSASyL4GiwCsGBhZEGrhmJetO+HHR+VAJTzfrRgwcJFwlZClHnWqv2YG1cMuzbw'
    b'YeYClHWccLvtPbIsd8tiorsNFAkkmyTJEkhqaRoF8b0ZkpU0b2EUo1/DN8Xlku2FgpIpFikg'
    b'SEAjAjMZDCsJfNjJQHppGZ8v+4zTKb9eKpVcilLwKkrJrSgl9VV2g+JQFMUBiqmInmwJvwUL'
    b'2PTCk4oilRwOm5zLRdoQ9f7y6mslCQyrb+Bii4KCURTUgSgMagPcgB8ImBY/4AVc6uKgvPqj'
    b'RQIWRjPMQixaUAmhLwFZRPHPJJAyvWboTwyDkcGwFwXVKlqYT1qmXLC1CykgKpeav7NDv/Kv'
    b'FiyMZlQSQBEh4FmEsGcxKgBr/egqm1l+JE3go9QDMJ+4xl7mcrEy4sSdGJqCmQDMlTIsWBgt'
    b'MD/3lYNpEUP9z2EQgKYZDGQGfCQMRgDm0X6w3ytP3Fy7WlG/04S/cvS3hN6ChfLmE2YtwEwC'
    b'Zg3gfH0AzDif7JZhIAK4UIcPs+qhnXTl+poZ4EAIv5kAGGB9CxZGIyplqZIENCLI058AzNtf'
    b'aP+D4mJNgPL2NEYrHDPMqowm+Nbob8HCwKj06pdMiyZH2vvBfAAfGh8lDAhGlhKmzxoBDEX4'
    b'LTKwMBpRKbSVJGD2rZmXYRN8DR82EchsY5hJQCMAG/2FHyyBt2BhIFR69GXKicD8ncIwksCF'
    b'GuOdz5lgXsfcE0qi/4hvEYAFC4NjoFl/lRpBJUmcTy6HTBDnE8iL6U1lThLSPlc2oLNgwcL5'
    b'Mdj034sZ+YeUAGRe+UK/XSikMNDobo34Fix8eFQSwUCvA+GiRn+A/w9bqXv2XKcyUAAAAABJ'
    b'RU5ErkJggg==')

class LightSoundDataReadPlot:
    def LightSoundReaderV2Raw(self,inputFilename):
        # make lists
        timezone = ''
        timestamp_list = []
        time_list = []
        lux_list = []
        gain_list = []
        integration_list = []

        # read in input file
        inputDataFile = open(inputFilename)
        lines = inputDataFile.readlines()
        inputDataFile.close()

        # loop over lines
        for l in range(len(lines)):
            currentline = lines[l]
            if currentline.startswith("Timezone"):
                linesplit = currentline.split(None)
                timezone = linesplit[1]			
            if currentline.startswith("Time:"):
                linesplit = currentline.split(None)
                timestamp = linesplit[1] + ' ' + linesplit[2]
                timestamp_fmt = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S.%f')
                timestamp_list.append(timestamp_fmt)
            elif currentline.startswith("["):
                linesplit = currentline.split(None)
                time = float(linesplit[1])
                time_list.append(time)
            elif currentline.startswith("Visible"):
                linesplit = currentline.split(None)
                lux = float(linesplit[2])
                lux_list.append(lux)
            elif currentline.startswith("Gain"):
                linesplit = currentline.split(None)
                gain = int(linesplit[1].strip('x'))
                gain_list.append(gain)
            elif currentline.startswith("Integration"):
                linesplit = currentline.split(None)
                integration = int(linesplit[1])
                integration_list.append(integration)
            else:
                pass

        # trim lists to have the same length
        endSeries = np.min([len(i) for i in [timestamp_list, time_list, lux_list, gain_list, integration_list]])
        timestamp_list = timestamp_list[:endSeries]
        time_list = time_list[:endSeries]
        lux_list = lux_list[:endSeries]
        gain_list = gain_list[:endSeries]
        integration_list = integration_list[:endSeries]

        return 	timezone, timestamp_list, time_list, lux_list, gain_list, integration_list
    
    def LightSoundReaderV2Data(self, inputFilename):
        # make lists
        timezone = ''
        timestamp_list = []
        time_list = []
        lux_list = []
        gain_list = []
        integration_list = []

        # read in input file
        inputDataFile = open(inputFilename)
        lines = inputDataFile.readlines()
        inputDataFile.close()

        # grab timezone
        timezone = lines[0].split(None)[1]

        # loop over lines
        for l in range(2,len(lines)):
            currentline = lines[l]
            linesplit = currentline.strip('\n').split(',')
            timestamp = datetime.strptime(linesplit[0], '%Y-%m-%d %H:%M:%S.%f')
            timestamp_list.append(timestamp)
            time = float(linesplit[1])
            time_list.append(time)
            lux = float(linesplit[2])
            lux_list.append(lux)
            gain = int(linesplit[3])
            gain_list.append(gain)
            integration = int(linesplit[4])
            integration_list.append(integration)

        return 	timezone, timestamp_list, time_list, lux_list, gain_list, integration_list

    def __init__(self, filename, savePlot, saveName):
        self.inputFile = filename
        self.savePlot = savePlot
        self.saveName = saveName
        fileEnding = filename.split('.')[-1]
        if fileEnding.split('.')[-1] == 'log': 
            self.timezone, self.timestamps, self.times, self.lux, self.gains, self.integrations = self.LightSoundReaderV2Raw(self.inputFile)
        elif fileEnding.split('.')[-1] == 'csv': 
            self.timezone, self.timestamps, self.times, self.lux, self.gains, self.integrations = self.LightSoundReaderV2Data(self.inputFile)

    def plotLuxOnly(self):
        # Plot data
        plt.close()
        fig, ax = plt.subplots()
        ax.plot(self.timestamps, self.lux, color='blue', label='Lux')

        # Format plot ticks
        xformatter = mdates.DateFormatter('%H:%M')
        ax.xaxis.set_major_formatter(xformatter)

        # Format plot title and labels
        ax.set_title(self.timestamps[0].strftime('Observations on %Y %b %d starting at %H:%M ') + self.timezone)
        ax.set_xlabel('Local time (%s)' % self.timezone)
        ax.set_ylabel('Intensity (Lux)')

        # Save image and show plot
        if self.savePlot == 1:
            plt.savefig(self.saveName, dpi=500, bbox_inches='tight')
            plt.show()
        else:
            plt.show()

    def plotLuxGainsInts(self):
        # Plot data
        plt.close()
        fig, ax = plt.subplots()
        ax.plot(self.timestamps, self.lux, color='blue', label='Lux')
        ax.plot(self.timestamps, self.gains, color='red', label='Gain')
        ax.plot(self.timestamps, self.integrations, color='green', label='Integration')

        # Format plot ticks
        xformatter = mdates.DateFormatter('%H:%M')
        ax.xaxis.set_major_formatter(xformatter)

        # Format plot title and labels
        ax.set_title(self.timestamps[0].strftime('Observations on %Y %b %d starting at %H:%M ') + self.timezone)
        ax.set_xlabel('Local time (%s)' % self.timezone)
        ax.set_ylabel('Intensity (Lux)')
        ax.legend(loc='upper right')

        # Save image and show plot
        if self.savePlot == 1:
            plt.savefig(self.saveName, dpi=500, bbox_inches='tight')
            plt.show()
        else:
            plt.show()

class MainFrame(wx.Frame):
    def __init__(self, parent):
        # Read in or make config file
        self.getConfig()

        # Set baud rate
        self.baud_rate = int(9600)
        
        # Find ports
        ports = serial.tools.list_ports.comports()
        self.portNames = [port.device for port in ports if port.vid in [9114,9025,4292]]
        self.portVIDs = [port.vid for port in ports if port.vid in [9114,9025,4292]]

        # Set up basics of GUI
        wx.Frame.__init__(self, parent, title="LightSound Computer Interface")
        self.MenuBar()
        self.panel = wx.Panel(self)   
        self.panel.SetFont(wx.Font(pointSize=12, family=wx.DEFAULT, style=wx.NORMAL, weight=wx.NORMAL))
        sectionTitleFont = wx.Font(pointSize=13, family=wx.DEFAULT, style=wx.NORMAL, weight=wx.BOLD)

        # Add LightSound icon
        logoImg = LightSoundLogoIcon()
        logoImg.GetImage()
        iconFile = logoImg.GetIcon()
        self.icon = wx.Icon(iconFile)
        self.SetIcon(self.icon)

        # Mode interface section
        self.modeTitle = wx.Button(self.panel, label="Choose Mode Type (click for help)")
        self.modeTitle.SetFont(sectionTitleFont)
        self.logBtn = wx.Button(self.panel, label='Mode 1: Click to start logging LightSound data ONLY')
        self.logBtnStop = wx.Button(self.panel, label='Click to STOP logging LightSound data')
        self.logBtnStop.SetBackgroundColour(wx.NullColour)
        self.liveplotBtn = wx.Button(self.panel, label='Mode 2: Click to liveplot LightSound data ONLY')
        self.logPlotBtn = wx.Button(self.panel, label='Mode 3: Click for simultaneous LightSound plotting and logging')
        self.plotOldBtn = wx.Button(self.panel, label='Mode 4: Click to plot pre-saved LightSound data')

        # Serial port section
        self.portTitle = wx.Button(self.panel, label="Serial Port Information (click for help)")
        self.portTitle.SetFont(sectionTitleFont)
        self.portLabel = wx.StaticText(self.panel, label="Choose serial port:")
        self.portChoice = wx.Choice(self.panel, choices = self.portNames)
        self.portConf = wx.StaticText(self.panel, label="Selected serial port:")
        self.portResult = wx.TextCtrl(self.panel, -1)
        self.portResult.SetEditable(0)
        self.portResult.AcceptsFocusFromKeyboard=lambda:True
        if len(self.portNames) == 1:
            self.portChoice.SetSelection(0)
            self.portResult.SetLabel(self.portNames[0])
        else:
            pass
        self.refreshPorts = wx.Button(self.panel, label="Click to refresh serial port list (if 'Choose serial port' dropdown menu is empty)")

        # Save information section    
        self.saveInfoTitle = wx.Button(self.panel, label="File Saving Preferences (click for help)")
        self.saveInfoTitle.SetFont(sectionTitleFont)
        self.saveInfoLabel = wx.StaticText(self.panel, label="Do you want to save data/plots?")
        saveInfoChoices = ["yes","no"]
        self.saveInfoChoice = wx.Choice(self.panel, choices = saveInfoChoices)
        self.saveInfoChoice.SetSelection(0)
        self.saveInfoConf = wx.StaticText(self.panel, label="Save info path/prefix:")
        self.defaultSaveLoc = str(Path(os.getcwd()) / str("LightSoundData/" + datetime.now().strftime("%Y-%m-%d-%H%M%S")+"-LightSound"))
        self.saveInfoResult = wx.TextCtrl(self.panel, -1, style = wx.TE_RICH2, size=(900, -1)) 
        self.saveInfoResult.SetLabel(self.defaultSaveLoc)
        self.saveInfoResult.SetEditable(0)
        self.saveInfoResult.AcceptsFocusFromKeyboard=lambda:True
        self.changeSaveInfo = wx.Button(self.panel, label='Click to change save location (optional)')
        self.refreshDefaultPath = wx.Button(self.panel, label='Click to refresh timestamp for default save location (use this if you get an overwrite warning)')

        # Timezone section
        self.tzTitle = wx.Button(self.panel, -1, label="Timezone Information (click for help)", style=wx.BORDER_NONE)
        self.tzTitle.SetFont(sectionTitleFont)
        self.tzLabel = wx.StaticText(self.panel, label="Enter timezone (optional):")
        self.tzField = wx.TextCtrl(self.panel, size=(140, -1), style=wx.TE_PROCESS_ENTER)
        self.tzEnter = wx.Button(self.panel, -1, label="Set entered timezone")
        self.tzConf = wx.StaticText(self.panel, label="Selected timezone (automatically set from computer clock):")
        self.tzResult = wx.TextCtrl(self.panel, -1)
        self.tzResult.SetLabel('UTC' + str(-time.timezone/3600.))
        self.tzResult.SetEditable(0)
        self.tzResult.AcceptsFocusFromKeyboard=lambda:True

        # Set sizer for the frame, so we can change frame size to match widgets
        self.windowSizer = wx.BoxSizer()
        self.windowSizer.Add(self.panel, 1, wx.ALL | wx.EXPAND)        

        # Set grid sizer
        self.sizer = wx.GridBagSizer(5, 2)

        # Set locations for the mode interface content
        modeFirstRow = 0
        self.sizer.Add(self.modeTitle,  (modeFirstRow,     0))
        self.sizer.Add(self.logBtn,     (modeFirstRow + 1, 0))
        self.sizer.Add(self.logBtnStop, (modeFirstRow + 1, 1))
        self.sizer.Add(self.liveplotBtn,(modeFirstRow + 2, 0))
        self.sizer.Add(self.logPlotBtn, (modeFirstRow + 3, 0))
        self.sizer.Add(self.plotOldBtn, (modeFirstRow + 4, 0))

        # Set locations for the port choice panel content
        portFirstRow = modeFirstRow + 4 + 2
        self.sizer.Add(self.portTitle,    (portFirstRow,     0))
        self.sizer.Add(self.portLabel,    (portFirstRow + 1, 0))
        self.sizer.Add(self.portChoice,   (portFirstRow + 1, 1)) 
        self.sizer.Add(self.portConf,     (portFirstRow + 2, 0))
        self.sizer.Add(self.portResult,   (portFirstRow + 2, 1))
        self.sizer.Add(self.refreshPorts, (portFirstRow + 3, 0))

        # Set locations for the save information panel content
        saveInfoFirstRow = portFirstRow + 3 + 2
        self.sizer.Add(self.saveInfoTitle,      (saveInfoFirstRow,     0))
        self.sizer.Add(self.saveInfoLabel,      (saveInfoFirstRow + 1, 0))
        self.sizer.Add(self.saveInfoChoice,     (saveInfoFirstRow + 1, 1))
        self.sizer.Add(self.saveInfoConf,       (saveInfoFirstRow + 2, 0))
        self.sizer.Add(self.saveInfoResult,     (saveInfoFirstRow + 3, 0))
        self.sizer.Add(self.changeSaveInfo,     (saveInfoFirstRow + 4, 0))
        self.sizer.Add(self.refreshDefaultPath, (saveInfoFirstRow + 5, 0))

        # Set locations for the timezone panel content  
        tzFirstRow = saveInfoFirstRow + 5 + 2
        self.sizer.Add(self.tzTitle,  (tzFirstRow,     0))
        self.sizer.Add(self.tzLabel,  (tzFirstRow + 1, 0))
        self.sizer.Add(self.tzField,  (tzFirstRow + 1, 1))
        self.sizer.Add(self.tzEnter,  (tzFirstRow + 1, 2))
        self.sizer.Add(self.tzConf,   (tzFirstRow + 2, 0))
        self.sizer.Add(self.tzResult, (tzFirstRow + 2, 1))

        # Set event handlers
        self.tzTitle.Bind(wx.EVT_BUTTON, self.TZHelp)
        self.tzField.Bind(wx.EVT_TEXT_ENTER,self.OnTZFieldEnter) 
        self.tzEnter.Bind(wx.EVT_BUTTON, self.OnTZSet)

        self.portTitle.Bind(wx.EVT_BUTTON, self.portHelp)
        self.portChoice.Bind(wx.EVT_CHOICE, self.OnPortChoice)
        self.refreshPorts.Bind(wx.EVT_BUTTON, self.OnPortRefresh)

        self.saveInfoTitle.Bind(wx.EVT_BUTTON, self.saveInfoHelp)
        self.saveInfoChoice.Bind(wx.EVT_CHOICE, self.OnSaveInfoChoice)
        self.changeSaveInfo.Bind(wx.EVT_BUTTON, self.OnChangeSaveLoc)
        self.refreshDefaultPath.Bind(wx.EVT_BUTTON, self.OnRefreshDefaultPath)

        self.modeTitle.Bind(wx.EVT_BUTTON, self.modeHelp)
        self.logBtn.Bind(wx.EVT_BUTTON, self.OnLogButton) 
        self.logBtnStop.Bind(wx.EVT_BUTTON, self.OnLogButtonStop)  
        self.liveplotBtn.Bind(wx.EVT_BUTTON, self.OnLiveplotButton) 
        self.logPlotBtn.Bind(wx.EVT_BUTTON, self.OnLogPlotBtn)  
        self.plotOldBtn.Bind(wx.EVT_BUTTON, self.OnPlotOldBtn)  

        # Set simple sizer for a nice border
        self.border = wx.BoxSizer()
        self.border.Add(self.sizer, 1, wx.ALL | wx.EXPAND, 5)

        # Use the sizers
        self.panel.SetSizerAndFit(self.border)  
        self.SetSizerAndFit(self.windowSizer)
        self.Centre()

        # If no ports are found, show dialog window
        if self.showNoPortDialog == 'True':
            if len(self.portNames) == 0:
                noPortDlg = self.noPortDlgStartup()
                if noPortDlg.ShowModal() == 5104:
                    sys.exit()
                else:
                    if noPortDlg.IsCheckBoxChecked():
                        self.showNoPortDialog = 'False'
                        self.getConfig(mode=1)
        else:
            pass

        # Setup hotkeys for exiting
        randomId = wx.NewIdRef()
        self.Bind(wx.EVT_MENU, self.onKeyCombo, id=randomId)
        accel_tbl = wx.AcceleratorTable([(wx.ACCEL_CTRL,  ord('Q'), randomId),(wx.ACCEL_CTRL,  ord('W'), randomId)])
        self.SetAcceleratorTable(accel_tbl)

        # If no ports are found, show dialog window
        if self.showStartDialog == 'True':
            startupDlg = self.startUpWindow()
            startupDlg.ShowModal()
            if startupDlg.IsCheckBoxChecked():
                self.showStartDialog = 'False'
                self.getConfig(mode=1)
            
        # Check if PCB LightSound and show dialog for it
        if len(self.portNames) != 0 and self.portVIDs[self.portChoice.GetSelection()] == 4292:
            self.pcbDlg()

        # Set initial focus to panel
        self.panel.AcceptsFocusFromKeyboard=lambda:True
        self.panel.SetFocus()

    def getConfig(self,mode=0):
        configName = str(Path(os.getcwd()) / 'LightSoundInterfaceConfig.ini')
        if mode==0:
            if os.path.isfile(configName):
                config = configparser.ConfigParser()
                config.read(configName)
                config.sections()
                self.showStartDialog = config['dialog.start']['showStartDialog']
                self.showNoPortDialog = config['dialog.noPort']['showNoPortDialog'] 
                self.showHelpDialog = config['dialog.help']['showHelpDialog'] 
            else:
                config = configparser.ConfigParser()
                config['dialog.start'] = {'showStartDialog':True}
                config['dialog.noPort'] = {'showNoPortDialog':True}
                config['dialog.help'] = {'showHelpDialog':True}
                with open(configName, 'w') as configFile:
                    config.write(configFile)
                configFile.close()
                self.showStartDialog = 'True'
                self.showNoPortDialog = 'True'
                self.showHelpDialog = 'True'
        elif mode==1:
            config = configparser.ConfigParser()
            config['dialog.start'] = {'showStartDialog':self.showStartDialog}
            config['dialog.noPort'] = {'showNoPortDialog':self.showNoPortDialog}
            config['dialog.help'] = {'showHelpDialog':self.showHelpDialog}
            with open(configName, 'w') as configFile:
                config.write(configFile)
            configFile.close()  
        else:
            config = configparser.ConfigParser()
            config['dialog.start'] = {'showStartDialog':True}
            config['dialog.noPort'] = {'showNoPortDialog':True}
            config['dialog.help'] = {'showHelpDialog':True}
            with open(configName, 'w') as configFile:
                config.write(configFile)
            configFile.close()     
            self.showStartDialog = 'True'
            self.showNoPortDialog = 'True'
            self.showHelpDialog = 'True'

    def onKeyCombo(self, event):
        if wx.MessageBox("Are you sure you want to close the application?",
                         "Exiting Application",
                         wx.YES_NO | wx.ICON_QUESTION) == wx.YES:
            self.Close()
        else:
            pass

    def MenuBar(self):    
        menubar = wx.MenuBar() 
            
        fileMenu = wx.Menu() 
        aboutItem = wx.MenuItem(fileMenu,wx.ID_ABOUT, text = "About LightSound Computer Interface",kind = wx.ITEM_NORMAL) 
        fileMenu.Append(aboutItem) 

        resetDefaultsItem = wx.MenuItem(fileMenu, wx.ID_RESET, '&Reset default settings for popup dialogs') 
        fileMenu.Append(resetDefaultsItem) 

        helpItemAcc = wx.MenuItem(fileMenu, wx.ID_HELP_CONTENTS, '&Help (screenreader accessible)') 
        fileMenu.Append(helpItemAcc) 

        helpItem = wx.MenuItem(fileMenu, wx.ID_HELP, '&Help') 
        fileMenu.Append(helpItem) 

        exitItem = wx.MenuItem(fileMenu, wx.ID_EXIT, '&Exit Interface\tCtrl+Q') 
        fileMenu.Append(exitItem) 

        menubar.Append(fileMenu, '&Menu') 
            
        self.SetMenuBar(menubar) 
        self.Bind(wx.EVT_MENU, self.menuhandler) 
        self.Show(True)

    def About(self):
        aboutInfo = wx.adv.AboutDialogInfo()
        aboutInfo.SetIcon(self.icon)
        aboutInfo.SetName("LightSound Computer Interface")
        aboutInfo.SetVersion("v1.0.0")
        aboutInfo.SetDescription("LightSound Computer Interface is designed for connecting\n"
                                +"a LightSound device to a computer for logging and\n"
                                +"liveplotting data. This interface also has a plotting\n"
                                +"mode, which can be used to plot pre-existing data from\n"
                                +"LightSound observations.")
        aboutInfo.SetCopyright("(C) SÃ³ley Hyman 2024")
        # aboutInfo.SetLicense("")
        aboutInfo.SetWebSite("https://soleyhyman.github.io/lightsound.html")
        wx.adv.AboutBox(aboutInfo)
            
    def menuhandler(self, event): 
        id = event.GetId() 
        if id == wx.ID_ABOUT: 
            self.About()
            return
        elif id == wx.ID_EXIT:
            self.Close()
        elif id == wx.ID_HELP_CONTENTS:
            if self.showHelpDialog == 'True':
                helpIntroDlg = self.helpIntro()
                helpIntroDlg.ShowModal()
                if helpIntroDlg.IsCheckBoxChecked():
                    self.showHelpDialog = 'False'
                    self.getConfig(mode=1)
            HelpPages(screenreader=True).Show()
        elif id == wx.ID_HELP:
            HelpPages(screenreader=False).Show()
        elif id == wx.ID_RESET:
            self.getConfig(mode=2)
            wx.MessageDialog(None, "Settings reset to default.",
                                   'Defaults Restored',
                                   wx.OK | wx.ICON_INFORMATION).ShowModal()
        else:
            pass       

    def startUpWindow(self):
        startupDlg = wx.RichMessageDialog(self, "Welcome to the LightSound Computer Interface!\n\n"
                                             + "In this program, you can log and liveplot LightSound data and plot data\n"
                                             + "that you have already saved. Each heading in the main window is a\n"
                                             + "clickable button that brings up information on how to use that section.\n"
                                             + " \n"
                                             + "To go to the Quick Start Guide, go to Menu and Help.\n"
                                             + " \n"
                                             + "To close any window, press Cmd+W. To exit the program, press Cmd+Q.", 
                                             "Start Up Information", wx.OK)
        startupDlg.ShowCheckBox("Don't show this again\n(Use spacebar to select with screenreader)")
        return startupDlg

    def noPortDlgStartup(self):
        noPortDlg = wx.RichMessageDialog(self, "No valid serial port has been found to connect to the LightSound.\n"
                                             + "If you are plotting pre-saved data, you may still use the interface.\n"
                                             + "Otherwise, please check your LightSound's computer connection, and\n"
                                             + "use the 'Click to refresh serial port list' button or try restarting\n"
                                             + "the LightSound Computer Interface.", 
                                             "No Valid Serial Port Found", wx.YES_NO|wx.ICON_WARNING)
        noPortDlg.SetYesNoLabels('Continue', 'Exit interface')
        noPortDlg.ShowDetailedText("Possible troubleshooting:\n"
                                    +"1. If you have a PCB LightSound, it must be switched ON for data to\n" 
                                    +"   transfer even while connected to the computer.\n"
                                    +"2. You may need to try multiple USB ports on your computer.\n"
                                    +"3. If neither of those solutions work, check that your LightSound is\n"
                                    +"   producing sound via headphones or speakers and that your micro-USB\n"
                                    +"   cable is capable of data transfer.")
        noPortDlg.ShowCheckBox("Don't show this again\n(Use spacebar to select with screenreader)")
        return noPortDlg
    
    def helpIntro(self):
        helpIntroDlg = wx.RichMessageDialog(self, "These are the help pages. If you are using a screenreader, you can\n"
                                                + "navigate through the different pages by using Shift+Tab, Tab,\n"
                                                + "Shift+Ctrl, and your arrow keys to move around.", 
                                             "Help Window Information", wx.OK)
        helpIntroDlg.ShowCheckBox("Don't show this again\n(Use spacebar to select with screenreader)")
        return helpIntroDlg

    def TZHelp(self,event):
        dlg = wx.MessageDialog(None, "Changing your timezone information\n\n"
                                    +"The field is automatically populated from your computer clock with"
                                    +" your Universal Time Coordinated (UTC) offset.\n"
                                    +" \n"
                                    +"If you desire, you may change this to your local, three-letter abbreviation."
                                    +" You can confirm your new timezone tag by pressing Enter while in the text"
                                    +" box, or by clicking the 'Set entered timezone' button.",
                                   'Timezone Information Help',
                                   wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()

    def OnTZFieldEnter(self,event):
        if self.tzField.GetValue() == "":
            return
        else:
            self.tzResult.SetLabel(self.tzField.GetValue())

    def OnTZSet(self, event):
        if self.tzField.GetValue() == "":
            return
        else:
            self.tzResult.SetLabel(self.tzField.GetValue())

    def portHelp(self,event):
        dlg = wx.MessageDialog(None, "Finding the LightSound's computer serial port (i.e., how it communicates with your computer)\n\n"
                                    +"If your LightSound is connected to your computer, there should typically only be"
                                    +" one port in the list that is automatically selected.\n"
                                    +" \n"
                                    +"If there are multiple ports found, you will need to select one from this list"
                                    +" and try logging or liveplotting until one works.\n"
                                    +" \n"
                                    +"If no port selections appear, try checking your cable connection and click the 'Refresh serial port list' button.",
                                   'Serial Port Information Help',
                                   wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()

    def OnPortChoice(self,event): 
        self.portResult.SetLabel(self.portChoice.GetString(self.portChoice.GetSelection()))
    
    def OnPortRefresh(self,event):
        ports = serial.tools.list_ports.comports()
        self.portNames = [port.device for port in ports if port.vid in [9114,9025,4292]]
        self.portVIDs = [port.vid for port in ports if port.vid in [9114,9025,4292]]
        self.portChoice.SetItems(self.portNames)
        if len(self.portNames) == 1:
            self.portChoice.SetSelection(0)
            self.portResult.SetLabel(self.portNames[0])
        elif len(self.portNames) == 0:
            self.portResult.SetLabel("")
            noPortDlg = wx.RichMessageDialog(self, "No valid serial port has been found to connect to the LightSound. Please\n"
                                                 + "check your LightSound's computer connection, and try refreshing the serial\n"
                                                 + "port list with the button 'Click to refresh serial port list'.", 
                                             "No Valid Serial Port Found", wx.OK|wx.ICON_WARNING)
            noPortDlg.ShowDetailedText("Possible troubleshooting:\n"
                                      +"1. If you have a PCB LightSound, it must be switched ON for data to\n" 
                                      +"   transfer even while connected to the computer.\n"
                                      +"2. You may need to try multiple USB ports on your computer.\n"
                                      +"3. If neither of those solutions work, check that your LightSound is\n"
                                      +"   producing sound via headphones or speakers and that your micro-USB\n"
                                      +"   cable is capable of data transfer.")
            noPortDlg.ShowModal()
        else:
            pass

        if len(self.portNames) != 0 and self.portVIDs[self.portChoice.GetSelection()] == 4292:
            self.pcbDlg()
        else:
            pass

    def saveInfoHelp(self,event):
        dlg = wx.MessageDialog(None, "Changing your saving your preferences\n\n"
                                    +"By default, 'Do you want to save data/plots?' is set to 'yes'.\n"
                                    +" \n"
                                    +"Unless you choose otherwise, files will save to the LightSoundData folder where the Interface"
                                    +" executable/application file is located.\n"
                                    +" \n"
                                    +"The default file prefix is timestamped to the year, month, day, hour, and second to avoid duplicate files.\n"
                                    +" \n"
                                    +"To change the save location or file prefix, use the 'Click to change save location'"
                                    +" button. This will open up a file dialog box.\n"
                                    +" \n"
                                    +"To regenerate a new default file prefix timestamp, use the 'Click to refresh timestamp for default save location' button.",
                                   'File Saving Preferences Help',
                                   wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
    
    def OnSaveInfoChoice(self,event): 
        overwriteDanger = True
        saveChoice = self.saveInfoChoice.GetString(self.saveInfoChoice.GetSelection())
        if saveChoice == "no":
            self.saveInfoResult.SetLabel("None")
        else:
            while overwriteDanger == True:
                if self.saveInfoResult.GetLabel() == "None":
                    self.saveInfoResult.SetLabel(self.defaultSaveLoc)
                else:
                    pass
                with wx.FileDialog(self, "Choose where to save file", wildcard="File prefix (no file extension)|*",
                            style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
                    if fileDialog.ShowModal() == wx.ID_CANCEL:
                        return     # if the user cancels the operation
                    
                    savePathString = fileDialog.GetPath()

                if os.path.isfile(savePathString+'_raw.log') or os.path.isfile(savePathString+'_data.csv') or os.path.isfile(savePathString+'.png'):
                    dlg = wx.MessageDialog(None, "File already exists. Do you want to overwrite?",'File Overwrite Warning',wx.YES_NO | wx.ICON_WARNING)
                    overwriteResult = dlg.ShowModal()
                    if overwriteResult == wx.ID_YES:
                        self.saveInfoResult.SetLabel(savePathString)
                        overwriteDanger = False
                        break
                    else:
                        pass
                else:
                    self.saveInfoResult.SetLabel(savePathString)
                    overwriteDanger = False

    def OnChangeSaveLoc(self,event): 
        overwriteDanger = True
        while overwriteDanger == True:
            with wx.FileDialog(self, "Choose where to save file", wildcard="File prefix (no file extension)|*",
                        style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    return     # if the user cancels the operation
                
                savePathString = fileDialog.GetPath()

            if os.path.isfile(savePathString+'_raw.log') or os.path.isfile(savePathString+'_data.csv') or os.path.isfile(savePathString+'.png'):
                dlg = wx.MessageDialog(None, "File already exists. Do you want to overwrite?",'File Overwrite Warning',wx.YES_NO | wx.ICON_WARNING)
                overwriteResult = dlg.ShowModal()
                if overwriteResult == wx.ID_YES:
                    self.saveInfoResult.SetLabel(savePathString)
                    overwriteDanger = False
                    break
                else:
                    pass
            else:
                self.saveInfoResult.SetLabel(savePathString)
                overwriteDanger = False

    def OnRefreshDefaultPath(self,event):
        self.saveInfoResult.SetLabel(str(Path(os.getcwd()) / str("LightSoundData/" + datetime.now().strftime("%Y-%m-%d-%H%M%S")+"-LightSound")))

    def checkTZProvided(self):
        if self.tzResult.GetLabel() == "":
            dlg = wx.MessageDialog(None, "No timezone provided. If you want to continue without providing a timezone, click 'Yes'. Otherwise, click 'No' to go back.",'No Timezone Provided Warning',wx.YES_NO | wx.ICON_WARNING)
            tzResultCheck = dlg.ShowModal()
            if tzResultCheck == wx.ID_YES:
                return True
            else:
                return False
        else:
            return True

    def checkCOMPortProvided(self):
        if self.portResult.GetLabel() == "":
            dlg = wx.MessageDialog(None, "No serial port selected. Please go back and select a port.",
                                   'No Serial Port Selected',
                                   wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            print('Exiting logging loop')
            return False
        try:
            serial.Serial(port=self.portResult.GetLabel())
            print('Serial port is good. Continuing.')
            return True
        except:
            dlg = wx.MessageDialog(None, "Not a valid serial port. Please go back and select a different port.",'Invalid Serial Port Selected',wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            print('Serial port is bad. Exiting loop.')
            return False
        
    def checkSaveChoiceProvided(self):
        if self.saveInfoChoice.GetString(self.saveInfoChoice.GetSelection()) == "no":
            dlg = wx.MessageDialog(None, "You have opted not to save your data/plot to a file. Are you sure about this?",'Warning: Data Will Not Be Saved to File',wx.YES_NO | wx.ICON_WARNING)
            saveChoiceCheck = dlg.ShowModal()
            if saveChoiceCheck == wx.ID_YES:
                return True
            else:
                return False
        else:
            return True
        
    def checkOverwriteSave(self, file_prefix):
        if os.path.isfile(file_prefix+'_raw.log') or \
            os.path.isfile(file_prefix+'_data.csv') or \
            os.path.isfile(file_prefix+'.png') or \
            os.path.isfile(file_prefix+'_liveplot.png'):
            dlg = wx.MessageDialog(None, "Data or image file of this name already exists. Do you want to overwrite them? This cannot be undone.\n"
                                   +" \n"
                                   +"If you do not want to overwrite, you can use the 'Click to refresh timestamp for default save location' button in the File Saving Preferences section to generate a new filename.",
                                   'File Overwrite Warning',
                                   wx.YES_NO | wx.ICON_WARNING)
            overwriteResult = dlg.ShowModal()
            if overwriteResult == wx.ID_YES:
                return True
            else:
                return False
        
    def modeHelp(self,event):
        dlg = wx.MessageDialog(None, "Choosing which interface mode to use\n\n"
                                    +"This section has four mode-selection buttons and one mode control button.\n"
                                    +" \n"
                                    +"Mode 1: 'Click to start logging LightSound data ONLY' will save the LightSound data\n"
                                    +"          in both raw form and CSV form (for use in a spreadsheet or other analysis).\n"
                                    +"          This method does not automatically save a plot of the data. Use the\n"
                                    +"          'Click to STOP logging LightSound data' to stop this logging.\n"
                                    +"\n"
                                    +"Mode 2: 'Click to liveplot LightSound data ONLY' will show a constantly-updating plot\n"
                                    +"          reflecting the live LightSound data. By default, this will automatically save\n"
                                    +"          your plot as a PNG file when you stop the data recording and close the \n"
                                    +"          liveplotting window that opens up with this button.\n"
                                    +"\n"
                                    +"Mode 3: 'Click for simultaneous LightSound plotting and logging' combines Modes 1 and 2\n"
                                    +"          to both liveplot and record the LightSound data in raw and CSV format. This mode\n"
                                    +"          will automatically save the recorded plot as a PNG image after closing the\n"
                                    +"          the liveplotting window.\n"
                                    +"\n"
                                    +"Mode 4: 'Click to plot pre-saved LightSound data' is the only mode that can be used\n"
                                    +"          without a LightSound connected to your computer. This method is used to plot\n"
                                    +"          existing LightSound data (e.g., generated from Mode 1 or from a previous\n"
                                    +"          eclipse, activity, or demonstration.)",
                                   'Mode Selection Help',
                                   wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
    
    def OnLogButtonStop(self,event):
        self.loggingStopBoolean = True
    
    def rawToCSV(self, file_prefix, timezone):
        # Read logged data and save it as columns in tab separated file
        # Read in logged data
        rawData = LightSoundDataReadPlot(filename=file_prefix+'_raw.log', 
                                       savePlot=1, 
                                       saveName=file_prefix+'.png')
        
        # rawData.plotLuxOnly()

        # Group data by rows
        with open(file_prefix+'_data.csv', 'w+') as col_file:
            col_file.writelines('Timezone: ' + timezone + '\n')
            col_file.writelines('Timestamp, Time (ms), Lux, Gain, Integration\n')

            for i in range(len(rawData.timestamps)):
                data_row = [rawData.timestamps[i], rawData.times[i], rawData.lux[i], rawData.gains[i], rawData.integrations[i]]
                col_file.writelines(','.join([str(i) for i in data_row]) + '\n')

        print('Logged data saved in columns')
        col_file.close()

    def loggingOnlyLoop(self, ser, file_prefix, timezone):
        # Open logging file and begin logging data
        self.loggingStopBoolean = False
        with open(file_prefix + '_raw.log', 'w+') as f:
            print('Timezone:', timezone, '\n')
            f.writelines('Timezone: ' + timezone + '\r \n')
            while self.loggingStopBoolean == False:
                timeNow = datetime.now()
                line = ser.readline()
                line = line.decode("utf-8")
                if line.startswith('['):
                    f.writelines('Time: ' + str(timeNow) + '\n')
                    print('Time:', timeNow)
                    f.writelines([line])
                    print(line.strip('\n'))	
                elif line.startswith('Visible'):
                    f.writelines([line])
                    print(line.strip('\n'))	
                else:
                    f.writelines([line])
                    print(line.strip('\n'))         
                if self.loggingStopBoolean == True:
                    break
        f.close()
        print('Logging terminated')
        self.rawToCSV(file_prefix, timezone)
        self.logBtnStop.SetBackgroundColour(wx.NullColour)
        dlg = wx.MessageDialog(None, "Currently, the LightSound Interface does not automatically plot the data. To plot your saved data, please click the 'Click to plot pre-saved LightSound data' button in the main window.",
                               'Plotting Saved Data',
                               wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()

    def OnLogButton(self,event):
        if self.checkTZProvided() == False:
            return
        elif self.checkCOMPortProvided() == False:
            return
        elif self.saveInfoResult.GetLabel() == "None":
            dlg = wx.MessageDialog(None, "The logging-only mode requires a save location. Please select 'yes' for 'Do you want to save data/plots?'",
                                   'Error: Need Save Location',
                                   wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            return
        elif self.checkOverwriteSave(self.saveInfoResult.GetLabel()) == False:
            return
        else:
            pass

        if len(self.portNames) != 0 and self.portVIDs[self.portChoice.GetSelection()] == 4292:
            self.pcbDlg()
        else:
            pass
        
        self.logBtnStop.SetBackgroundColour((0, 255, 0, 0))
        serial_port = self.portResult.GetLabel()
        ser = serial.Serial(serial_port, self.baud_rate)
        timezone = self.tzResult.GetLabel()
        file_prefix = self.saveInfoResult.GetLabel()
        thread = threading.Thread(target=self.loggingOnlyLoop, args=(ser, file_prefix, timezone, ))
        thread.start()
        dlg = wx.MessageDialog(None, "Data logging has begun. To stop logging data, please use the 'Click to STOP logging LightSound data' button.",
                                   'Data Logging Started',
                                   wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
        return

    def OnLiveplotButton(self,event):
        if self.checkTZProvided() == False:
            return
        elif self.checkCOMPortProvided() == False:
            return
        elif self.checkSaveChoiceProvided() == False:
            return
        elif self.checkOverwriteSave(self.saveInfoResult.GetLabel()) == False:
            return
        else:
            pass

        serial_port = self.portResult.GetLabel()
        timezone = self.tzResult.GetLabel()
        file_prefix = self.saveInfoResult.GetLabel()
        frame = liveplotFrame(serial_port, self.baud_rate, timezone, file_prefix)
        frame.Show()
        dlg = wx.MessageDialog(None, "Press Start/Stop toggle button below to begin liveplotting."
                                +" Press Stop to end live plotting. If you are using a screenreader,"
                                +" you can tab to the Start or Stop button and press the spacebar to"
                                +" start or stop as opposed to clicking. Exiting this window will"
                                +" automatically save plot. You can exit this window by pressing Cmd+W.",
                               'Ready to Start Liveplotting',
                               wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
        return
    
    def OnLogPlotBtn(self, event):
        if self.checkTZProvided() == False:
            return
        elif self.checkCOMPortProvided() == False:
            return
        elif self.saveInfoResult.GetLabel() == "None":
                dlg = wx.MessageDialog(None, "This mode requires a save location. Please select 'yes' for 'Do you want to save data/plots?'",
                                       'Error: Need Save Location',
                                       wx.OK | wx.ICON_ERROR)
                dlg.ShowModal()
        elif self.checkOverwriteSave(self.saveInfoResult.GetLabel()) == False:
            return
        else:
            pass

        serial_port = self.portResult.GetLabel()
        timezone = self.tzResult.GetLabel()
        file_prefix = self.saveInfoResult.GetLabel()
        frame = liveplotLogFrame(serial_port, self.baud_rate, timezone, file_prefix)
        frame.Show()
        dlg = wx.MessageDialog(None, "Press Start/Stop toggle button below to begin liveplotting."
                                +" Press Stop to end live plotting. If you are using a screenreader,"
                                +" you can tab to the Start or Stop button and press the spacebar to"
                                +" start or stop as opposed to clicking. Exiting this window will"
                                +" automatically save plot. You can exit this window by pressing Cmd+W.",
                               'Ready to Start Liveplotting/Logging',
                               wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
        return
    
    def OnPlotOldBtn(self, event):
        openFileDialog = wx.FileDialog(self, "Open", "", "", 
                                    "LightSound data files (*_raw.log;*_data.csv)|*_raw.log;*.csv", 
                                    wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)
        openFileDialog.ShowModal()
        inputFile = openFileDialog.GetPath()
        openFileDialog.Destroy()

        if os.path.isfile(inputFile): 
            plotDataWindow = plotDataFrame(inputFile, parent=self.panel)
            plotDataWindow.Show()
        else:
            pass

class liveplotFrame(wx.Frame):
    def __init__(self, serialport, baudrate, timezone, file_prefix):
        wx.Frame.__init__(self, parent = None, title = "LightSound Liveplotting", size = (600,600))
        splitter = wx.SplitterWindow(self)
        self.file_prefix = file_prefix
        self.top = self.liveplotPanel1(splitter, serialport, baudrate, timezone, file_prefix)
        self.bottom = self.liveplotPanel2(splitter, self.top, serialport, baudrate, timezone, file_prefix)
        splitter.SplitHorizontally(self.top, self.bottom)
        splitter.SetMinimumPaneSize(500)
        self.top.draw(0,0)

        self.Bind(wx.EVT_CLOSE, self.OnClose)

        # Hotkey for closing
        randomId = wx.NewIdRef()
        self.Bind(wx.EVT_MENU, self.OnCloseKeyCombo, id=randomId)
        accel_tbl = wx.AcceleratorTable([(wx.ACCEL_CTRL,  ord('Q'), randomId),(wx.ACCEL_CTRL,  ord('W'), randomId)])
        self.SetAcceleratorTable(accel_tbl)
      
    def OnCloseKeyCombo(self, event):
        try:
            if wx.MessageBox("Are you sure you want to exit liveplotting? Plot will automatically save by default.",
                            "Exiting Liveplotting",
                            wx.ICON_QUESTION | wx.YES_NO) != wx.YES:
                event.Veto()
                print('Not exiting')
                return
            else:
                pass

            if self.file_prefix != 'None':
                print('Saving liveplot...')
                self.top.figure.savefig(self.file_prefix+'_liveplot.png')
                plt.close(self.top.figure)
            else:
                pass
            print('Done!')
            self.bottom.timer.Stop()
            self.bottom.ser.flush()
            self.bottom.ser.close()
        except:
            pass
        self.Destroy()

    def OnClose(self, event):
        try:
            if event.CanVeto():
                if wx.MessageBox("Are you sure you want to exit liveplotting? Plot will automatically save by default.",
                                "Exiting Liveplotting",
                                wx.YES_NO | wx.ICON_QUESTION) != wx.YES:
                    event.Veto()
                    print('Not exiting')
                    return

            if self.file_prefix != 'None':
                print('Saving liveplot...')
                self.top.figure.savefig(self.file_prefix+'_liveplot.png')
                plt.close(self.top.figure)
            else:
                pass
            print('Done!')
            self.bottom.timer.Stop()
            self.bottom.ser.flush()
            self.bottom.ser.close()
        except:
            pass

        self.Destroy()
    
    class liveplotPanel1(wx.Panel):
        def __init__(self, parent, serialport, baudrate, timezone, file_prefix):
            wx.Panel.__init__(self, parent = parent)
            
            self.serialport = serialport
            self.baudrate = baudrate
            self.timezone = timezone
            self.file_prefix = file_prefix

            self.figure = Figure()
            self.axes = self.figure.add_subplot(111)
            self.initialTime = datetime.now()

            self.canvas = FigureCanvas(self, -1, self.figure)
            self.sizer = wx.BoxSizer(wx.VERTICAL)
            self.sizer.Add(self.canvas, 1, wx.EXPAND)
            self.SetSizer(self.sizer)
            
        def draw(self,x,y):
            self.axes.clear()
            if type(x) == int:
                self.axes.plot(x,y, 'b-')
            elif len(x) < 1000:
                self.axes.plot(x,y, 'b-')
            elif len(x) < 2000:
                self.axes.plot(x[::2],y[::2], 'b-')
            elif len(x) < 5000:
                self.axes.plot(x[::5],y[::5], 'b-')
            elif len(x) < 10000:
                self.axes.plot(x[::10],y[::10], 'b-')
            elif len(x) < 100000:
                self.axes.plot(x[::100],y[::100], 'b-')
            elif len(x) < 500000:
                self.axes.plot(x[::1000],y[::1000], 'b-')
            self.axes.set_title(self.initialTime.strftime('Observations on %Y %b %d starting at %H:%M ') + self.timezone)
            self.axes.set_xlabel('Local time (%s)' % self.timezone)
            self.axes.set_ylabel('Intensity (Lux)')
            self.canvas.draw()
            
        def changeAxes(self, min, max):
            self.axes.set_ylim(float(min), float(max))
            self.canvas.draw()

    class liveplotPanel2(wx.Panel):
        def __init__(self, parent, top, serialport, baudrate, timezone, file_prefix):
            wx.Panel.__init__(self, parent = parent)

            self.serialport = serialport
            self.baudrate = baudrate
            self.timezone = timezone
            self.file_prefix = file_prefix
            self.graph = top
            self.parent = parent
            
            self.togglebuttonStart = wx.ToggleButton(self, id = -1, label = "Start", pos = (10,10))
            self.togglebuttonStart.SetBackgroundColour((0, 255, 0))
            self.togglebuttonStart.Bind(wx.EVT_TOGGLEBUTTON, self.OnStartClick)
            
            self.timer = wx.Timer(self)
            self.Bind(wx.EVT_TIMER, self.TimeInterval, self.timer)

            self.serial_connection = False

            self.x = np.array([])
            self.y = np.array([])     
            
        def TimeInterval(self, event):
            tmp = self.ser.readline().decode('utf-8')
            if tmp.startswith('Visible'):
                self.y = np.append(self.y, float(tmp.split(None)[2]))
                self.x = np.append(self.x, datetime.now())
                self.graph.draw(self.x, self.y)
            else:
                pass 

        def OnStartClick(self, event):
            val = self.togglebuttonStart.GetValue()
            if (val == True):
                if MainFrame.checkOverwriteSave(self, self.file_prefix) == False:
                    return
                else:
                    pass
                self.x = np.array([])
                self.y = np.array([]) 
                self.togglebuttonStart.SetLabel("Stop")
                self.togglebuttonStart.SetBackgroundColour((255, 0, 0))
                self.timer.Start(50)
                self.ser = serial.Serial(self.serialport, self.baudrate, timeout = 2)
            else:
                self.togglebuttonStart.SetLabel("Start")
                self.togglebuttonStart.SetBackgroundColour((0, 255, 0))
                self.timer.Stop()
                if self.file_prefix != 'None':
                    self.graph.figure.savefig(self.file_prefix+'_liveplot.png')
                else:
                    pass
                try:
                    self.ser.flush()
                    self.ser.close()
                except:
                    pass
                
class liveplotLogFrame(wx.Frame):
    def __init__(self, serialport, baudrate, timezone, file_prefix):
        wx.Frame.__init__(self, parent = None, title = "LightSound Liveplotting and Logging", size = (600,600))
        splitter = wx.SplitterWindow(self)
        self.serialport = serialport
        self.baudrate = baudrate
        self.timezone = timezone
        self.file_prefix = file_prefix

        self.logFile = open(self.file_prefix + '_raw.log', 'w+')
        self.logFile.writelines('Timezone: ' + timezone + '\r \n')

        self.top = self.liveplotLogPanel1(splitter, serialport, baudrate, timezone, file_prefix, self.logFile)
        self.bottom = self.liveplotLogPanel2(splitter, self.top, serialport, baudrate, timezone, file_prefix, self.logFile)
        splitter.SplitHorizontally(self.top, self.bottom)
        splitter.SetMinimumPaneSize(500)
        self.top.draw(0,0)

        self.Bind(wx.EVT_CLOSE, self.OnClose)

        # Hotkey for closing
        randomId = wx.NewIdRef()
        self.Bind(wx.EVT_MENU, self.OnCloseKeyCombo, id=randomId)
        accel_tbl = wx.AcceleratorTable([(wx.ACCEL_CTRL,  ord('Q'), randomId),(wx.ACCEL_CTRL,  ord('W'), randomId)])
        self.SetAcceleratorTable(accel_tbl)

    def OnCloseKeyCombo(self, event):
        try:
            if wx.MessageBox("Are you sure you want to exit liveplotting? Plot will automatically save by default.",
                            "Exiting Liveplotting",
                            wx.ICON_QUESTION | wx.YES_NO) != wx.YES:
                event.Veto()
                print('Not exiting')
                return
            else:
                pass

            if self.file_prefix != 'None':
                print('Saving liveplot...')
                self.top.figure.savefig(self.file_prefix+'_liveplot.png')
                plt.close(self.top.figure)
            else:
                pass
            print('Done!')
            self.bottom.timer.Stop()
            self.bottom.ser.flush()
            self.bottom.ser.close()
        except:
            pass
        self.Destroy()

    def OnClose(self, event):
        try:
            if event.CanVeto():
                if wx.MessageBox("Are you sure you want to exit liveplotting? Plot will automatically save by default.",
                                "Exiting Liveplotting",
                                wx.ICON_QUESTION | wx.YES_NO) != wx.YES:
                    event.Veto()
                    print('Not exiting')
                    return

            print('Logging terminated.')
            self.logFile.close()
            MainFrame.rawToCSV(self,self.file_prefix, self.timezone)
            
            print('Saving liveplot...')
            self.top.figure.savefig(self.file_prefix+'_liveplot.png')
            plt.close(self.top.figure)
            print('Done!')

            self.bottom.timer.Stop()
            self.bottom.ser.flush()
            self.bottom.ser.close()
        except:
            pass

        self.Destroy()
    
    class liveplotLogPanel1(wx.Panel):
        def __init__(self, parent, serialport, baudrate, timezone, file_prefix, logFile):
            wx.Panel.__init__(self, parent = parent)
            
            self.serialport = serialport
            self.baudrate = baudrate
            self.timezone = timezone
            self.file_prefix = file_prefix
            self.logFile = logFile

            self.figure = Figure()
            self.axes = self.figure.add_subplot(111)
            self.initialTime = datetime.now()

            self.canvas = FigureCanvas(self, -1, self.figure)
            self.sizer = wx.BoxSizer(wx.VERTICAL)
            self.sizer.Add(self.canvas, 1, wx.EXPAND)
            self.SetSizer(self.sizer)
            
        # def draw(self,x,y):
        #     self.axes.clear()
        #     self.axes.plot(x,y, 'b-')
        #     self.axes.set_title(self.initialTime.strftime('Observations on %Y %b %d starting at %H:%M ') + self.timezone)
        #     self.axes.set_xlabel('Local time (%s)' % self.timezone)
        #     self.axes.set_ylabel('Intensity (Lux)')
        #     self.canvas.draw()
        def draw(self,x,y):
            self.axes.clear()
            if type(x) == int:
                self.axes.plot(x,y, 'b-')
            elif len(x) < 1000:
                self.axes.plot(x,y, 'b-')
            elif len(x) < 2000:
                self.axes.plot(x[::2],y[::2], 'b-')
            elif len(x) < 5000:
                self.axes.plot(x[::5],y[::5], 'b-')
            elif len(x) < 10000:
                self.axes.plot(x[::10],y[::10], 'b-')
            elif len(x) < 100000:
                self.axes.plot(x[::100],y[::100], 'b-')
            elif len(x) < 500000:
                self.axes.plot(x[::1000],y[::1000], 'b-')
            self.axes.set_title(self.initialTime.strftime('Observations on %Y %b %d starting at %H:%M ') + self.timezone)
            self.axes.set_xlabel('Local time (%s)' % self.timezone)
            self.axes.set_ylabel('Intensity (Lux)')
            self.canvas.draw()
            
        def changeAxes(self, min, max):
            self.axes.set_ylim(float(min), float(max))
            self.canvas.draw()

    class liveplotLogPanel2(wx.Panel):
        def __init__(self, parent, top, serialport, baudrate, timezone, file_prefix, logFile):
            wx.Panel.__init__(self, parent = parent)

            self.serialport = serialport
            self.baudrate = baudrate
            self.timezone = timezone
            self.file_prefix = file_prefix
            self.logFile = logFile
            self.graph = top
            self.nStartClicks = 0 
            
            self.togglebuttonStart = wx.ToggleButton(self, id = -1, label = "Start", pos = (10,10))
            self.togglebuttonStart.SetBackgroundColour((0, 255, 0))
            self.togglebuttonStart.Bind(wx.EVT_TOGGLEBUTTON, self.OnStartClick)
            
            self.timer = wx.Timer(self)
            self.Bind(wx.EVT_TIMER, self.TimeInterval, self.timer)

            self.serial_connection = False

            self.x = np.array([])
            self.y = np.array([])     
            
        def TimeInterval(self, event):
            line = self.ser.readline().decode('utf-8')
            timeNow = datetime.now()
            if line.startswith('['):
                    self.logFile.writelines('Time: ' + str(timeNow) + '\n')
                    self.logFile.writelines([line])
            elif line.startswith('Visible'):
                self.logFile.writelines([line])
                self.y = np.append(self.y, float(line.split(None)[2]))
                self.x = np.append(self.x, timeNow)
                self.graph.draw(self.x, self.y)
            else:
                self.logFile.writelines([line])

        def OnStartClick(self, event):
            val = self.togglebuttonStart.GetValue()
            if (val == True):
                if self.nStartClicks>0 and MainFrame.checkOverwriteSave(self,self.file_prefix) == False:
                    return
                else:
                    self.nStartClicks += 1
                self.x = np.array([])
                self.y = np.array([]) 
                self.togglebuttonStart.SetLabel("Stop")
                self.togglebuttonStart.SetBackgroundColour((255, 0, 0))
                self.timer.Start(50)
                self.ser = serial.Serial(self.serialport, self.baudrate, timeout = 2)
            else:
                self.togglebuttonStart.SetLabel("Start")
                self.togglebuttonStart.SetBackgroundColour((0, 255, 0))
                self.timer.Stop()
                print('Logging terminated.')
                self.logFile.close()
                MainFrame.rawToCSV(self,self.file_prefix, self.timezone)
                self.graph.figure.savefig(self.file_prefix+'_liveplot.png')

                print('Saving liveplot...')
                try:
                    self.ser.flush()
                    self.ser.close()
                except:
                    return

class plotDataFrame(wx.Frame):
    def __init__(self,inputFile, parent):
        # New window setup
        wx.Frame.__init__(self, parent, -1,'Plotting options')
        self.MenuBar()
        self.panelPlotDat=wx.Panel(self, -1)
        self.panelPlotDat.SetFont(wx.Font(pointSize=12, family=wx.DEFAULT, style=wx.NORMAL, weight=wx.NORMAL))
        self.inputFile = inputFile
        
        # New window title
        self.plotOptionsTitle = wx.Button(self.panelPlotDat, label="Plotting Options (click for help)")
        sectionTitleFont = wx.Font(pointSize=13, family=wx.DECORATIVE, style=wx.NORMAL, weight=wx.BOLD)
        self.plotOptionsTitle.SetFont(sectionTitleFont)

        # Plot lines section
        self.plotLinesLabel = wx.StaticText(self.panelPlotDat, label="Choose what data to plot (optional):")
        self.plotLinesChoices = ["Light measurements only","Light measurements, gain, and integration-time data"]
        self.plotLinesChoice = wx.Choice(self.panelPlotDat, choices = self.plotLinesChoices)
        self.plotLinesConf = wx.StaticText(self.panelPlotDat, label="Plotting:")
        self.plotLinesResult = wx.TextCtrl(self.panelPlotDat, style = wx.TE_RICH2, size=(250, -1)) 
        self.plotLinesChoice.SetSelection(0)
        self.plotLinesResult.SetLabel(self.plotLinesChoices[0])
        self.plotLinesResult.SetEditable(0)
        self.plotLinesResult.AcceptsFocusFromKeyboard=lambda:True

        # Plot save/view section
        self.plotSaveLabel = wx.StaticText(self.panelPlotDat, label="Do you want to view or save the plot? (optional)")
        self.plotSaveChoices = ["View plot only","View and save plot"]
        self.plotSaveChoice = wx.Choice(self.panelPlotDat, choices = self.plotSaveChoices)
        self.plotSaveConf = wx.StaticText(self.panelPlotDat, label="Saving/viewing mode:")
        self.plotSaveResult = wx.StaticText(self.panelPlotDat, label="") 
        self.plotSavePath = wx.StaticText(self.panelPlotDat, label="Saving to:")
        self.savePathResult = wx.TextCtrl(self.panelPlotDat, style = wx.TE_RICH2, size=(250, -1)) 
        self.savePathResult.SetEditable(0)
        self.savePathResult.AcceptsFocusFromKeyboard=lambda:True

        # Save path info
        self.changeSavePath= wx.Button(self.panelPlotDat, label='Click to change save location or filetype (optional)')
        self.plotSaveChoice.SetSelection(1)
        self.plotSaveResult.SetLabel(self.plotSaveChoices[1])
        self.plotSaveChoiceIndex = 1
        # self.savePathResult.SetLabel("None")
        self.savePathResult.SetLabel(self.getDefaultSaveName())

        # Plot data button
        self.plotDataBtn = wx.Button(self.panelPlotDat, label='Click to plot the selected data')

        # Set sizer for the frame, so we can change frame size to match widgets
        self.windowSizerPlotDat = wx.BoxSizer()
        self.windowSizerPlotDat.Add(self.panelPlotDat, 1, wx.ALL | wx.EXPAND)        

        # Set grid sizer
        self.sizerPlotDat = wx.GridBagSizer(5, 5)

        # Set location for new window title
        self.sizerPlotDat.Add(self.plotOptionsTitle,  (0, 0))

        # Set locations for the plot lines panel content  
        linesFirstRow = 0
        self.sizerPlotDat.Add(self.plotLinesLabel,  (linesFirstRow + 1, 0))
        self.sizerPlotDat.Add(self.plotLinesChoice, (linesFirstRow + 1, 1))
        self.sizerPlotDat.Add(self.plotLinesConf,   (linesFirstRow + 2, 0))
        self.sizerPlotDat.Add(self.plotLinesResult, (linesFirstRow + 2, 1))

        # Set locations for the plot lines panel content  
        saveFirstRow = 4
        self.sizerPlotDat.Add(self.plotSaveLabel,  (saveFirstRow + 1, 0))
        self.sizerPlotDat.Add(self.plotSaveChoice, (saveFirstRow + 1, 1))
        self.sizerPlotDat.Add(self.plotSaveConf,   (saveFirstRow + 2, 0))
        self.sizerPlotDat.Add(self.plotSaveResult, (saveFirstRow + 2, 1))
        self.sizerPlotDat.Add(self.plotSavePath,   (saveFirstRow + 3, 0))
        self.sizerPlotDat.Add(self.savePathResult, (saveFirstRow + 3, 1))
        self.sizerPlotDat.Add(self.changeSavePath, (saveFirstRow + 4, 0), (1, 2))

        # Set locations for the plot data button
        plotFirstRow = 10
        self.sizerPlotDat.Add(self.plotDataBtn,    (plotFirstRow, 0), (1, 2))

        # Set event handlers
        self.plotOptionsTitle.Bind(wx.EVT_BUTTON, self.OnPlotOptionsHelp) 
        self.plotLinesChoice.Bind(wx.EVT_CHOICE, self.OnPlotLinesChoice)
        self.plotSaveChoice.Bind(wx.EVT_CHOICE, self.OnPlotSaveChoice)
        self.plotDataBtn.Bind(wx.EVT_BUTTON, self.OnPlotDataButton) 
        self.changeSavePath.Bind(wx.EVT_BUTTON, self.OnChangeSaveLocImage) 

        # Set simple sizer for a nice border
        self.borderPlotDat = wx.BoxSizer()
        self.borderPlotDat.Add(self.sizerPlotDat, 1, wx.ALL | wx.EXPAND, 5)

        # Use the sizers
        self.panelPlotDat.SetSizerAndFit(self.borderPlotDat)  
        self.SetSizerAndFit(self.windowSizerPlotDat)  
        self.Centre()

        # Hotkey for closing
        randomId = wx.NewIdRef()
        self.Bind(wx.EVT_MENU, self.OnCloseWinKeyCombo, id=randomId)
        accel_tbl = wx.AcceleratorTable([(wx.ACCEL_CTRL,  ord('Q'), randomId),(wx.ACCEL_CTRL,  ord('W'), randomId)])
        self.SetAcceleratorTable(accel_tbl)

        self.panelPlotDat.AcceptsFocusFromKeyboard=lambda:True
        self.panelPlotDat.SetFocus()
    
    def OnPlotOptionsHelp(self, event):
        dlg = wx.MessageDialog(None, "Plotting Options allows you to select your plotting preferences.\n"
                                    +" \n"
                                    +"The first section allows you to choose whether to plot\n"
                                    +"    1) the light brightness data (i.e., Lux values) only or\n"
                                    +"    2) the Lux values and detector information (i.e., gain and integration time)\n"
                                    +" \n"
                                    +"The second section asks whether you want to view the plot or view and save the plot."
                                    +" The 'Click to change save location or filetype' button allows to you choose where to"
                                    +" save your plot file, as well as what format to save it as. You can choose from a list"
                                    +" of PNG, JPEG, PDF, EPS, and SVG formats.\n"
                                    +" \n"
                                    +"To plot, use the 'Click to plot the selected data' button.",
                                   'Plot Options Help',
                                   wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
    
    def MenuBar(self):    
        menubar = wx.MenuBar() 
            
        fileMenu = wx.Menu()            
        exitItem = wx.MenuItem(fileMenu, wx.ID_EXIT, '&Exit Window\Cmd+W') 
        fileMenu.Append(exitItem) 

        menubar.Append(fileMenu, '&Menu') 
            
        self.SetMenuBar(menubar) 
        self.Bind(wx.EVT_MENU, self.menuhandler) 
        self.Show(True)
            
    def menuhandler(self, event): 
        id = event.GetId() 
        if id == wx.ID_EXIT:
            self.Close()
        else:
            pass

    def OnCloseWinKeyCombo(self, event):
        self.Close()

    def OnPlotLinesChoice(self,event): 
        self.plotLinesResult.SetLabel(self.plotLinesChoice.GetString(self.plotLinesChoice.GetSelection()))

    def getDefaultSaveName(self):
        if '_raw.log' in self.inputFile:
                defaultSaveName = self.inputFile.split("_raw.log")[0] + ".png"
        else:
            defaultSaveName = self.inputFile.split("_data.csv")[0] + ".png"
        return defaultSaveName

    def OnPlotSaveChoice(self,event): 
        self.plotSaveResult.SetLabel(self.plotSaveChoice.GetString(self.plotSaveChoice.GetSelection()))
        self.plotSaveChoiceIndex = self.plotSaveChoices.index(self.plotSaveChoice.GetString(self.plotSaveChoice.GetSelection()))
        if self.plotSaveChoiceIndex==1 and self.savePathResult.GetLabel() == "None":
            self.savePathResult.SetLabel(self.getDefaultSaveName())
        elif self.plotSaveChoiceIndex==0 and self.savePathResult.GetLabel() != "None":
            self.savePathResult.SetLabel("None")
        else:
            pass

    def OnChangeSaveLocImage(self,event): 
        self.plotSaveChoice.SetSelection(1)
        self.plotSaveResult.SetLabel(self.plotSaveChoices[1])
        self.plotSaveChoiceIndex = 1
        self.savePathResult.SetLabel(self.getDefaultSaveName())
        overwriteDanger = True
        saveImgWildcard = "PNG Image (*.png)|*.png|" \
                          "JPEG Image (*.jpg)|*.jpg|" \
                          "PDF File (*.pdf)|*.pdf|" \
                          "EPS File (*.eps)|*.eps|" \
                          "SVG File (*.svg)|*.svg"
        while overwriteDanger == True:
            with wx.FileDialog(self, "Choose where to save file",  
                               defaultFile=Path(self.getDefaultSaveName()).name, 
                               wildcard=saveImgWildcard,
                               style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:
                if fileDialog.ShowModal() == wx.ID_CANCEL:
                    return     # if the user cancels the operation
                
                savePathString = fileDialog.GetPath()

            if os.path.isfile(savePathString):
                dlg = wx.MessageDialog(None, "File already exists. Do you want to overwrite?",'File Overwrite Warning',wx.YES_NO | wx.ICON_WARNING)
                overwriteResult = dlg.ShowModal()
                if overwriteResult == wx.ID_YES:
                    self.savePathResult.SetLabel(savePathString)
                    overwriteDanger = False
                    break
                else:
                    pass
            else:
                self.savePathResult.SetLabel(savePathString)
                overwriteDanger = False
    
    def OnPlotDataButton(self,event): 
        try:
            inputData = LightSoundDataReadPlot(filename=self.inputFile, 
                                        savePlot=self.plotSaveChoiceIndex, 
                                        saveName=self.savePathResult.GetLabel()) 
            if self.plotLinesResult.GetLabel() == self.plotLinesChoices[0]:
                inputData.plotLuxOnly()
            else:
                inputData.plotLuxGainsInts()
        except:
            dlg = wx.MessageDialog(None, "Issue with plotting data. Please check that the data file is not empty or corrupted.",
                                   'Plotting Error',
                                   wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            self.Close()
     
class MyHTMLParser(HTMLParser):
    def __init__(self):
        super().__init__()
        self.data = []
        self.capture = False
    def handle_starttag(self, tag, attrs):
        if tag in ('p', 'h1', 'h2', 'h3'):
            self.capture = True
    def handle_endtag(self, tag):
        if tag in ('p', 'h1', 'h2', 'h3'):
            self.capture = False
    def handle_data(self, data):
        if self.capture:
            self.data.append(data)

class HelpPages(wx.Frame):
    def __init__(self, screenreader=False):
        if screenreader==True:
            wx.Frame.__init__(self, None, title="Help Pages (accessible)", size=(500,500))
        else:
            wx.Frame.__init__(self, None, title="Help Pages", size=(500,500))

        # Here we create a panel and a notebook on the panel
        p = wx.Panel(self)
        self.nb = wx.Notebook(p)

        # create the page windows as children of the notebook
        page1 = self.helpPage(self.nb,self.helpText('quick'), screenreader)
        page2 = self.helpPage(self.nb,self.helpText('kbrd'), screenreader)
        page3 = self.helpPage(self.nb,self.helpText('contact'), screenreader)

        # add the pages to the notebook with the label to show on the tab
        self.nb.AddPage(page1, "Quick Start Guide")
        self.nb.AddPage(page2, "Keyboard Shortcuts")
        self.nb.AddPage(page3, "Contact")

        # finally, put the notebook in a sizer for the panel to manage
        # the layout
        sizer = wx.BoxSizer()
        sizer.Add(self.nb, 1, wx.EXPAND)
        p.SetSizer(sizer)
        self.Centre()

        # Hotkey for closing
        randomId = wx.NewIdRef()
        self.Bind(wx.EVT_MENU, self.OnCloseWinKeyCombo, id=randomId)
        accel_tbl = wx.AcceleratorTable([(wx.ACCEL_CTRL,  ord('Q'), randomId),(wx.ACCEL_CTRL,  ord('W'), randomId)])
        self.SetAcceleratorTable(accel_tbl)

        # Link clicking
        self.nb.Bind(html.EVT_HTML_LINK_CLICKED, self.onLinkClicked)

    def MenuBar(self):    
        menubar = wx.MenuBar() 
            
        fileMenu = wx.Menu()            
        exitItem = wx.MenuItem(fileMenu, wx.ID_EXIT, '&Exit Window\Cmd+W') 
        fileMenu.Append(exitItem) 

        menubar.Append(fileMenu, '&Menu') 
            
        self.SetMenuBar(menubar) 
        self.Bind(wx.EVT_MENU, self.menuhandler) 
        self.Show(True)
            
    def menuhandler(self, event): 
        id = event.GetId() 
        if id == wx.ID_EXIT:
            self.Close()
        else:
            pass

    def OnCloseWinKeyCombo(self, event):
        self.Close()

    def helpText(self,keyword):
        quickStartHTML = "<h1>Quick Start Guide</h1>" +\
                "<p>While the LightSound Computer Interface has several different controls for customization, you can get started by clikcing one of the four 'Mode' buttons in the 'Choose Mode Type' section. </p>" +\
                "<h2>Choosing your Mode</h2>" +\
                "<p>The first section of the main interface ('Choose Mode Type') presents four different ways you can use this program:</p>" +\
                "<ul>" + \
                    "<li><b>Mode 1:</b> This mode saves (i.e., logs) the LightSound readings in a separate window and saves them to a text file. There is no visual feedback from this.</li>" + \
                    "<li><b>Mode 2:</b> This mode plots the LightSound data as it comes in. The axes of the graph will automatically adjust as new data comes in. This mode will automatically save the plot, although you can disable that in the 'File Saving Preferences' section below, if desired.</li>" + \
                    "<li><b>Mode 3:</b> This mode combines Mode 1 and Mode 2 and will always save the data log and the resulting plot.</li>" + \
                    "<li><b>Mode 4:</b> This mode allows you to select a LightSound data file and plot it. If you use Mode 1, you can use this mode after you finish logging data to produce a plot.</li>" + \
                "</ul>" + \
                "<h2>Serial Port</h2>" + \
                "<p>If you start the LightSound Computer Interface with your LightSound already connected to your computer, this program should automatically find the serial port (i.e., the name of the USB port that you've plugged the LightSound into).</p>" + \
                "<p>If you get a serial port error or there is nothing in the <b>Choose serial port</b> dropdown menu under <b>Serial Port Information</b>, check your cable connection and use the <b>Click to refresh serial port list</b> button.</p>" + \
                "<h2>Optional: File Saving Preferences and Timezone Information</h2>" + \
                "<p>These sections are automatically filled -- you don't need to touch these if they are confusing! <b>All you really need to know is that all data and plot files are saved in the same LightSoundData folder where this program is located</b> (i.e., wherever you clicked on the icon to run the LightSound Computer Interface).</p>"
        #
        kbrdShortsHTML = "<h1>Keyboard Shortcuts</h1>" +\
                        "<p>This program has a few keyboard shortcuts that you can use. They are as follows:</p>" +\
                        "<ul>" +\
                            "<li><b>Cmd+W:</b> Use this to close any popup window. (Cmd+W on Mac)</li>" +\
                            "<li><b>Cmd+Q:</b> Use this to exit the program. (Cmd+Q on Mac)</li>" +\
                        "</ul>"
        #
        contactHTML = "<h1>Additional Help</h1>" +\
                        "<p>If you find a bug or typo in this interface, or if you need additional help, please submit an issue via our GitHub (<a href='https://github.com/soleyhyman/LightSound2.0'>https://github.com/soleyhyman/LightSound2.0</a>) or our Google Form (<a href='https://forms.gle/NTnxsw4MNvdQT7tn7'>https://forms.gle/NTnxsw4MNvdQT7tn7</a>).</p>"
        #
        helpDict = {'quick':quickStartHTML,'kbrd':kbrdShortsHTML, 'contact':contactHTML}
        return helpDict[keyword]
        
    def onLinkClicked(self, link):
        print('link clicked')
        url = link.GetLinkInfo().GetHref()
        print(url)
        webbrowser.open(url)

    class helpPage(wx.Panel):
        def __init__(self, parent, text, screenreader=False):
            wx.Panel.__init__(self, parent)
            if screenreader == True:
                parser = MyHTMLParser()
                parser.feed(text)
                htmlText = parser.data
                strText = htmlText[0]+': ' + ''.join(htmlText[1:])
                textbox = wx.TextCtrl(self, -1, style = wx.TE_RICH2|wx.TE_WORDWRAP, size=(470, 430))
                textbox.SetLabel(strText)
                textbox.SetEditable(0)
            else: 
                txt_style = wx.VSCROLL|wx.HSCROLL|wx.TE_READONLY|wx.BORDER_SIMPLE
                textbox = html.HtmlWindow(self, -1, size=(470, 430), style=txt_style)
                textbox.SetPage(text)
            textbox.AcceptsFocusFromKeyboard=lambda:True
    
if __name__ == '__main__':
    app = wx.App(False)
    frame = MainFrame(None)
    frame.Show()
    app.MainLoop()